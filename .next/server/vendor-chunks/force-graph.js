"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/force-graph";
exports.ids = ["vendor-chunks/force-graph"];
exports.modules = {

/***/ "(ssr)/./node_modules/force-graph/dist/force-graph.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/force-graph/dist/force-graph.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ forceGraph)\n/* harmony export */ });\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ \"(ssr)/./node_modules/d3-zoom/src/index.js\");\n/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! d3-drag */ \"(ssr)/./node_modules/d3-drag/src/drag.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-array */ \"(ssr)/./node_modules/d3-array/src/min.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-array */ \"(ssr)/./node_modules/d3-array/src/max.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! d3-array */ \"(ssr)/./node_modules/d3-array/src/sum.js\");\n/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! lodash-es */ \"(ssr)/./node_modules/lodash-es/throttle.js\");\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tweenjs/tween.js */ \"(ssr)/./node_modules/@tweenjs/tween.js/dist/tween.esm.js\");\n/* harmony import */ var kapsule__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! kapsule */ \"(ssr)/./node_modules/kapsule/dist/kapsule.mjs\");\n/* harmony import */ var accessor_fn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! accessor-fn */ \"(ssr)/./node_modules/accessor-fn/dist/accessor-fn.mjs\");\n/* harmony import */ var canvas_color_tracker__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! canvas-color-tracker */ \"(ssr)/./node_modules/canvas-color-tracker/dist/canvas-color-tracker.mjs\");\n/* harmony import */ var float_tooltip__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! float-tooltip */ \"(ssr)/./node_modules/float-tooltip/dist/float-tooltip.mjs\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/simulation.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/link.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/manyBody.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/center.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/radial.js\");\n/* harmony import */ var bezier_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! bezier-js */ \"(ssr)/./node_modules/bezier-js/src/bezier.js\");\n/* harmony import */ var index_array_by__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! index-array-by */ \"(ssr)/./node_modules/index-array-by/dist/index-array-by.mjs\");\n/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-scale */ \"(ssr)/./node_modules/d3-scale/src/ordinal.js\");\n/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-scale-chromatic */ \"(ssr)/./node_modules/d3-scale-chromatic/src/categorical/Paired.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction styleInject(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = ref.insertAt;\n  if (typeof document === 'undefined') {\n    return;\n  }\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css_248z = \".force-graph-container canvas {\\n  display: block;\\n  user-select: none;\\n  outline: none;\\n  -webkit-tap-highlight-color: transparent;\\n}\\n\\n.force-graph-container .clickable {\\n  cursor: pointer;\\n}\\n\\n.force-graph-container .grabbable {\\n  cursor: move;\\n  cursor: grab;\\n  cursor: -moz-grab;\\n  cursor: -webkit-grab;\\n}\\n\\n.force-graph-container .grabbable:active {\\n  cursor: grabbing;\\n  cursor: -moz-grabbing;\\n  cursor: -webkit-grabbing;\\n}\\n\";\nstyleInject(css_248z);\n\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction _construct(t, e, r) {\n  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);\n  var o = [null];\n  o.push.apply(o, e);\n  var p = new (t.bind.apply(t, o))();\n  return p;\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: true,\n    configurable: true,\n    writable: true\n  }) : e[r] = t, e;\n}\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function () {\n    return !!t;\n  })();\n}\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = true,\n      o = false;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = true, n = r;\n    } finally {\n      try {\n        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), true).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _slicedToArray(r, e) {\n  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r);\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\n\nvar autoColorScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_6__[\"default\"]);\n\n// Autoset attribute colorField by colorByAccessor property\n// If an object has already a color, don't set it\n// Objects can be nodes or links\nfunction autoColorObjects(objects, colorByAccessor, colorField) {\n  if (!colorByAccessor || typeof colorField !== 'string') return;\n  objects.filter(function (obj) {\n    return !obj[colorField];\n  }).forEach(function (obj) {\n    obj[colorField] = autoColorScale(colorByAccessor(obj));\n  });\n}\n\nfunction getDagDepths (_ref, idAccessor) {\n  var nodes = _ref.nodes,\n    links = _ref.links;\n  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref2$nodeFilter = _ref2.nodeFilter,\n    nodeFilter = _ref2$nodeFilter === void 0 ? function () {\n      return true;\n    } : _ref2$nodeFilter,\n    _ref2$onLoopError = _ref2.onLoopError,\n    onLoopError = _ref2$onLoopError === void 0 ? function (loopIds) {\n      throw \"Invalid DAG structure! Found cycle in node path: \".concat(loopIds.join(' -> '), \".\");\n    } : _ref2$onLoopError;\n  // linked graph\n  var graph = {};\n  nodes.forEach(function (node) {\n    return graph[idAccessor(node)] = {\n      data: node,\n      out: [],\n      depth: -1,\n      skip: !nodeFilter(node)\n    };\n  });\n  links.forEach(function (_ref3) {\n    var source = _ref3.source,\n      target = _ref3.target;\n    var sourceId = getNodeId(source);\n    var targetId = getNodeId(target);\n    if (!graph.hasOwnProperty(sourceId)) throw \"Missing source node with id: \".concat(sourceId);\n    if (!graph.hasOwnProperty(targetId)) throw \"Missing target node with id: \".concat(targetId);\n    var sourceNode = graph[sourceId];\n    var targetNode = graph[targetId];\n    sourceNode.out.push(targetNode);\n    function getNodeId(node) {\n      return _typeof(node) === 'object' ? idAccessor(node) : node;\n    }\n  });\n  var foundLoops = [];\n  traverse(Object.values(graph));\n  var nodeDepths = Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(graph).filter(function (_ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2),\n      node = _ref5[1];\n    return !node.skip;\n  }).map(function (_ref6) {\n    var _ref7 = _slicedToArray(_ref6, 2),\n      id = _ref7[0],\n      node = _ref7[1];\n    return _defineProperty({}, id, node.depth);\n  }))));\n  return nodeDepths;\n  function traverse(nodes) {\n    var nodeStack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var currentDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var _loop = function _loop() {\n      var node = nodes[i];\n      if (nodeStack.indexOf(node) !== -1) {\n        var loop = [].concat(_toConsumableArray(nodeStack.slice(nodeStack.indexOf(node))), [node]).map(function (d) {\n          return idAccessor(d.data);\n        });\n        if (!foundLoops.some(function (foundLoop) {\n          return foundLoop.length === loop.length && foundLoop.every(function (id, idx) {\n            return id === loop[idx];\n          });\n        })) {\n          foundLoops.push(loop);\n          onLoopError(loop);\n        }\n        return 1; // continue\n      }\n      if (currentDepth > node.depth) {\n        // Don't unnecessarily revisit chunks of the graph\n        node.depth = currentDepth;\n        traverse(node.out, [].concat(_toConsumableArray(nodeStack), [node]), currentDepth + (node.skip ? 0 : 1));\n      }\n    };\n    for (var i = 0, l = nodes.length; i < l; i++) {\n      if (_loop()) continue;\n    }\n  }\n}\n\n//\n\nvar DAG_LEVEL_NODE_RATIO = 2;\n\n// whenever styling props are changed that require a canvas redraw\nvar notifyRedraw = function notifyRedraw(_, state) {\n  return state.onNeedsRedraw && state.onNeedsRedraw();\n};\nvar updDataPhotons = function updDataPhotons(_, state) {\n  if (!state.isShadow) {\n    // Add photon particles\n    var linkParticlesAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticles);\n    state.graphData.links.forEach(function (link) {\n      var numPhotons = Math.round(Math.abs(linkParticlesAccessor(link)));\n      if (numPhotons) {\n        link.__photons = _toConsumableArray(Array(numPhotons)).map(function () {\n          return {};\n        });\n      } else {\n        delete link.__photons;\n      }\n    });\n  }\n};\nvar CanvasForceGraph = (0,kapsule__WEBPACK_IMPORTED_MODULE_7__[\"default\"])({\n  props: {\n    graphData: {\n      \"default\": {\n        nodes: [],\n        links: []\n      },\n      onChange: function onChange(_, state) {\n        state.engineRunning = false; // Pause simulation\n        updDataPhotons(_, state);\n      }\n    },\n    dagMode: {\n      onChange: function onChange(dagMode, state) {\n        // td, bu, lr, rl, radialin, radialout\n        !dagMode && (state.graphData.nodes || []).forEach(function (n) {\n          return n.fx = n.fy = undefined;\n        }); // unfix nodes when disabling dag mode\n      }\n    },\n    dagLevelDistance: {},\n    dagNodeFilter: {\n      \"default\": function _default(node) {\n        return true;\n      }\n    },\n    onDagError: {\n      triggerUpdate: false\n    },\n    nodeRelSize: {\n      \"default\": 4,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    // area per val unit\n    nodeId: {\n      \"default\": 'id'\n    },\n    nodeVal: {\n      \"default\": 'val',\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    nodeColor: {\n      \"default\": 'color',\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    nodeAutoColorBy: {},\n    nodeCanvasObject: {\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    nodeCanvasObjectMode: {\n      \"default\": function _default() {\n        return 'replace';\n      },\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    nodeVisibility: {\n      \"default\": true,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkSource: {\n      \"default\": 'source'\n    },\n    linkTarget: {\n      \"default\": 'target'\n    },\n    linkVisibility: {\n      \"default\": true,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkColor: {\n      \"default\": 'color',\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkAutoColorBy: {},\n    linkLineDash: {\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkWidth: {\n      \"default\": 1,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkCurvature: {\n      \"default\": 0,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkCanvasObject: {\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkCanvasObjectMode: {\n      \"default\": function _default() {\n        return 'replace';\n      },\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkDirectionalArrowLength: {\n      \"default\": 0,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkDirectionalArrowColor: {\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkDirectionalArrowRelPos: {\n      \"default\": 0.5,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    // value between 0<>1 indicating the relative pos along the (exposed) line\n    linkDirectionalParticles: {\n      \"default\": 0,\n      triggerUpdate: false,\n      onChange: updDataPhotons\n    },\n    // animate photons travelling in the link direction\n    linkDirectionalParticleSpeed: {\n      \"default\": 0.01,\n      triggerUpdate: false\n    },\n    // in link length ratio per frame\n    linkDirectionalParticleOffset: {\n      \"default\": 0,\n      triggerUpdate: false\n    },\n    // starting position offset along the link's length, like a pre-delay. Values between [0, 1]\n    linkDirectionalParticleWidth: {\n      \"default\": 4,\n      triggerUpdate: false\n    },\n    linkDirectionalParticleColor: {\n      triggerUpdate: false\n    },\n    linkDirectionalParticleCanvasObject: {\n      triggerUpdate: false\n    },\n    globalScale: {\n      \"default\": 1,\n      triggerUpdate: false\n    },\n    d3AlphaMin: {\n      \"default\": 0,\n      triggerUpdate: false\n    },\n    d3AlphaDecay: {\n      \"default\": 0.0228,\n      triggerUpdate: false,\n      onChange: function onChange(alphaDecay, state) {\n        state.forceLayout.alphaDecay(alphaDecay);\n      }\n    },\n    d3AlphaTarget: {\n      \"default\": 0,\n      triggerUpdate: false,\n      onChange: function onChange(alphaTarget, state) {\n        state.forceLayout.alphaTarget(alphaTarget);\n      }\n    },\n    d3VelocityDecay: {\n      \"default\": 0.4,\n      triggerUpdate: false,\n      onChange: function onChange(velocityDecay, state) {\n        state.forceLayout.velocityDecay(velocityDecay);\n      }\n    },\n    warmupTicks: {\n      \"default\": 0,\n      triggerUpdate: false\n    },\n    // how many times to tick the force engine at init before starting to render\n    cooldownTicks: {\n      \"default\": Infinity,\n      triggerUpdate: false\n    },\n    cooldownTime: {\n      \"default\": 15000,\n      triggerUpdate: false\n    },\n    // ms\n    onUpdate: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onFinishUpdate: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onEngineTick: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onEngineStop: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onNeedsRedraw: {\n      triggerUpdate: false\n    },\n    isShadow: {\n      \"default\": false,\n      triggerUpdate: false\n    }\n  },\n  methods: {\n    // Expose d3 forces for external manipulation\n    d3Force: function d3Force(state, forceName, forceFn) {\n      if (forceFn === undefined) {\n        return state.forceLayout.force(forceName); // Force getter\n      }\n      state.forceLayout.force(forceName, forceFn); // Force setter\n      return this;\n    },\n    d3ReheatSimulation: function d3ReheatSimulation(state) {\n      state.forceLayout.alpha(1);\n      this.resetCountdown();\n      return this;\n    },\n    // reset cooldown state\n    resetCountdown: function resetCountdown(state) {\n      state.cntTicks = 0;\n      state.startTickTime = new Date();\n      state.engineRunning = true;\n      return this;\n    },\n    isEngineRunning: function isEngineRunning(state) {\n      return !!state.engineRunning;\n    },\n    tickFrame: function tickFrame(state) {\n      !state.isShadow && layoutTick();\n      paintLinks();\n      !state.isShadow && paintArrows();\n      !state.isShadow && paintPhotons();\n      paintNodes();\n      return this;\n\n      //\n\n      function layoutTick() {\n        if (state.engineRunning) {\n          if (++state.cntTicks > state.cooldownTicks || new Date() - state.startTickTime > state.cooldownTime || state.d3AlphaMin > 0 && state.forceLayout.alpha() < state.d3AlphaMin) {\n            state.engineRunning = false; // Stop ticking graph\n            state.onEngineStop();\n          } else {\n            state.forceLayout.tick(); // Tick it\n            state.onEngineTick();\n          }\n        }\n      }\n      function paintNodes() {\n        var getVisibility = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVisibility);\n        var getVal = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVal);\n        var getColor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeColor);\n        var getNodeCanvasObjectMode = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeCanvasObjectMode);\n        var ctx = state.ctx;\n\n        // Draw wider nodes by 1px on shadow canvas for more precise hovering (due to boundary anti-aliasing)\n        var padAmount = state.isShadow / state.globalScale;\n        var visibleNodes = state.graphData.nodes.filter(getVisibility);\n        ctx.save();\n        visibleNodes.forEach(function (node) {\n          var nodeCanvasObjectMode = getNodeCanvasObjectMode(node);\n          if (state.nodeCanvasObject && (nodeCanvasObjectMode === 'before' || nodeCanvasObjectMode === 'replace')) {\n            // Custom node before/replace paint\n            state.nodeCanvasObject(node, ctx, state.globalScale);\n            if (nodeCanvasObjectMode === 'replace') {\n              ctx.restore();\n              return;\n            }\n          }\n\n          // Draw wider nodes by 1px on shadow canvas for more precise hovering (due to boundary anti-aliasing)\n          var r = Math.sqrt(Math.max(0, getVal(node) || 1)) * state.nodeRelSize + padAmount;\n          ctx.beginPath();\n          ctx.arc(node.x, node.y, r, 0, 2 * Math.PI, false);\n          ctx.fillStyle = getColor(node) || 'rgba(31, 120, 180, 0.92)';\n          ctx.fill();\n          if (state.nodeCanvasObject && nodeCanvasObjectMode === 'after') {\n            // Custom node after paint\n            state.nodeCanvasObject(node, state.ctx, state.globalScale);\n          }\n        });\n        ctx.restore();\n      }\n      function paintLinks() {\n        var getVisibility = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkVisibility);\n        var getColor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkColor);\n        var getWidth = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkWidth);\n        var getLineDash = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkLineDash);\n        var getCurvature = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkCurvature);\n        var getLinkCanvasObjectMode = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkCanvasObjectMode);\n        var ctx = state.ctx;\n\n        // Draw wider lines by 2px on shadow canvas for more precise hovering (due to boundary anti-aliasing)\n        var padAmount = state.isShadow * 2;\n        var visibleLinks = state.graphData.links.filter(getVisibility);\n        visibleLinks.forEach(calcLinkControlPoints); // calculate curvature control points for all visible links\n\n        var beforeCustomLinks = [],\n          afterCustomLinks = [],\n          defaultPaintLinks = visibleLinks;\n        if (state.linkCanvasObject) {\n          var replaceCustomLinks = [],\n            otherCustomLinks = [];\n          visibleLinks.forEach(function (d) {\n            return ({\n              before: beforeCustomLinks,\n              after: afterCustomLinks,\n              replace: replaceCustomLinks\n            }[getLinkCanvasObjectMode(d)] || otherCustomLinks).push(d);\n          });\n          defaultPaintLinks = [].concat(_toConsumableArray(beforeCustomLinks), afterCustomLinks, otherCustomLinks);\n          beforeCustomLinks = beforeCustomLinks.concat(replaceCustomLinks);\n        }\n\n        // Custom link before paints\n        ctx.save();\n        beforeCustomLinks.forEach(function (link) {\n          return state.linkCanvasObject(link, ctx, state.globalScale);\n        });\n        ctx.restore();\n\n        // Bundle strokes per unique color/width/dash for performance optimization\n        var linksPerColor = (0,index_array_by__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(defaultPaintLinks, [getColor, getWidth, getLineDash]);\n        ctx.save();\n        Object.entries(linksPerColor).forEach(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            color = _ref2[0],\n            linksPerWidth = _ref2[1];\n          var lineColor = !color || color === 'undefined' ? 'rgba(0,0,0,0.15)' : color;\n          Object.entries(linksPerWidth).forEach(function (_ref3) {\n            var _ref4 = _slicedToArray(_ref3, 2),\n              width = _ref4[0],\n              linesPerLineDash = _ref4[1];\n            var lineWidth = (width || 1) / state.globalScale + padAmount;\n            Object.entries(linesPerLineDash).forEach(function (_ref5) {\n              var _ref6 = _slicedToArray(_ref5, 2);\n                _ref6[0];\n                var links = _ref6[1];\n              var lineDashSegments = getLineDash(links[0]);\n              ctx.beginPath();\n              links.forEach(function (link) {\n                var start = link.source;\n                var end = link.target;\n                if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n                ctx.moveTo(start.x, start.y);\n                var controlPoints = link.__controlPoints;\n                if (!controlPoints) {\n                  // Straight line\n                  ctx.lineTo(end.x, end.y);\n                } else {\n                  // Use quadratic curves for regular lines and bezier for loops\n                  ctx[controlPoints.length === 2 ? 'quadraticCurveTo' : 'bezierCurveTo'].apply(ctx, _toConsumableArray(controlPoints).concat([end.x, end.y]));\n                }\n              });\n              ctx.strokeStyle = lineColor;\n              ctx.lineWidth = lineWidth;\n              ctx.setLineDash(lineDashSegments || []);\n              ctx.stroke();\n            });\n          });\n        });\n        ctx.restore();\n\n        // Custom link after paints\n        ctx.save();\n        afterCustomLinks.forEach(function (link) {\n          return state.linkCanvasObject(link, ctx, state.globalScale);\n        });\n        ctx.restore();\n\n        //\n\n        function calcLinkControlPoints(link) {\n          var curvature = getCurvature(link);\n          if (!curvature) {\n            // straight line\n            link.__controlPoints = null;\n            return;\n          }\n          var start = link.source;\n          var end = link.target;\n          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          var l = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2)); // line length\n\n          if (l > 0) {\n            var a = Math.atan2(end.y - start.y, end.x - start.x); // line angle\n            var d = l * curvature; // control point distance\n\n            var cp = {\n              // control point\n              x: (start.x + end.x) / 2 + d * Math.cos(a - Math.PI / 2),\n              y: (start.y + end.y) / 2 + d * Math.sin(a - Math.PI / 2)\n            };\n            link.__controlPoints = [cp.x, cp.y];\n          } else {\n            // Same point, draw a loop\n            var _d = curvature * 70;\n            link.__controlPoints = [end.x, end.y - _d, end.x + _d, end.y];\n          }\n        }\n      }\n      function paintArrows() {\n        var ARROW_WH_RATIO = 1.6;\n        var ARROW_VLEN_RATIO = 0.2;\n        var getLength = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalArrowLength);\n        var getRelPos = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalArrowRelPos);\n        var getVisibility = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkVisibility);\n        var getColor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalArrowColor || state.linkColor);\n        var getNodeVal = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVal);\n        var ctx = state.ctx;\n        ctx.save();\n        state.graphData.links.filter(getVisibility).forEach(function (link) {\n          var arrowLength = getLength(link);\n          if (!arrowLength || arrowLength < 0) return;\n          var start = link.source;\n          var end = link.target;\n          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          var startR = Math.sqrt(Math.max(0, getNodeVal(start) || 1)) * state.nodeRelSize;\n          var endR = Math.sqrt(Math.max(0, getNodeVal(end) || 1)) * state.nodeRelSize;\n          var arrowRelPos = Math.min(1, Math.max(0, getRelPos(link)));\n          var arrowColor = getColor(link) || 'rgba(0,0,0,0.28)';\n          var arrowHalfWidth = arrowLength / ARROW_WH_RATIO / 2;\n\n          // Construct bezier for curved lines\n          var bzLine = link.__controlPoints && _construct(bezier_js__WEBPACK_IMPORTED_MODULE_4__.Bezier, [start.x, start.y].concat(_toConsumableArray(link.__controlPoints), [end.x, end.y]));\n          var getCoordsAlongLine = bzLine ? function (t) {\n            return bzLine.get(t);\n          } // get position along bezier line\n          : function (t) {\n            return {\n              // straight line: interpolate linearly\n              x: start.x + (end.x - start.x) * t || 0,\n              y: start.y + (end.y - start.y) * t || 0\n            };\n          };\n          var lineLen = bzLine ? bzLine.length() : Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));\n          var posAlongLine = startR + arrowLength + (lineLen - startR - endR - arrowLength) * arrowRelPos;\n          var arrowHead = getCoordsAlongLine(posAlongLine / lineLen);\n          var arrowTail = getCoordsAlongLine((posAlongLine - arrowLength) / lineLen);\n          var arrowTailVertex = getCoordsAlongLine((posAlongLine - arrowLength * (1 - ARROW_VLEN_RATIO)) / lineLen);\n          var arrowTailAngle = Math.atan2(arrowHead.y - arrowTail.y, arrowHead.x - arrowTail.x) - Math.PI / 2;\n          ctx.beginPath();\n          ctx.moveTo(arrowHead.x, arrowHead.y);\n          ctx.lineTo(arrowTail.x + arrowHalfWidth * Math.cos(arrowTailAngle), arrowTail.y + arrowHalfWidth * Math.sin(arrowTailAngle));\n          ctx.lineTo(arrowTailVertex.x, arrowTailVertex.y);\n          ctx.lineTo(arrowTail.x - arrowHalfWidth * Math.cos(arrowTailAngle), arrowTail.y - arrowHalfWidth * Math.sin(arrowTailAngle));\n          ctx.fillStyle = arrowColor;\n          ctx.fill();\n        });\n        ctx.restore();\n      }\n      function paintPhotons() {\n        var getNumPhotons = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticles);\n        var getSpeed = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleSpeed);\n        var getOffset = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleOffset);\n        var getDiameter = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleWidth);\n        var getVisibility = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkVisibility);\n        var getColor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleColor || state.linkColor);\n        var ctx = state.ctx;\n        ctx.save();\n        state.graphData.links.filter(getVisibility).forEach(function (link) {\n          var numCyclePhotons = getNumPhotons(link);\n          if (!link.hasOwnProperty('__photons') || !link.__photons.length) return;\n          var start = link.source;\n          var end = link.target;\n          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          var particleSpeed = getSpeed(link);\n          var particleOffset = Math.abs(getOffset(link));\n          var photons = link.__photons || [];\n          var photonR = Math.max(0, getDiameter(link) / 2) / Math.sqrt(state.globalScale);\n          var photonColor = getColor(link) || 'rgba(0,0,0,0.28)';\n          ctx.fillStyle = photonColor;\n\n          // Construct bezier for curved lines\n          var bzLine = link.__controlPoints ? _construct(bezier_js__WEBPACK_IMPORTED_MODULE_4__.Bezier, [start.x, start.y].concat(_toConsumableArray(link.__controlPoints), [end.x, end.y])) : null;\n          var cyclePhotonIdx = 0;\n          var needsCleanup = false; // whether some photons need to be removed from list\n          photons.forEach(function (photon) {\n            var singleHop = !!photon.__singleHop;\n            if (!photon.hasOwnProperty('__progressRatio')) {\n              photon.__progressRatio = singleHop ? 0 : (cyclePhotonIdx + particleOffset) / numCyclePhotons;\n            }\n            !singleHop && cyclePhotonIdx++; // increase regular photon index\n\n            photon.__progressRatio += particleSpeed;\n            if (photon.__progressRatio >= 1) {\n              if (!singleHop) {\n                photon.__progressRatio = photon.__progressRatio % 1;\n              } else {\n                needsCleanup = true;\n                return;\n              }\n            }\n            var photonPosRatio = photon.__progressRatio;\n            var coords = bzLine ? bzLine.get(photonPosRatio) // get position along bezier line\n            : {\n              // straight line: interpolate linearly\n              x: start.x + (end.x - start.x) * photonPosRatio || 0,\n              y: start.y + (end.y - start.y) * photonPosRatio || 0\n            };\n            if (state.linkDirectionalParticleCanvasObject) {\n              state.linkDirectionalParticleCanvasObject(coords.x, coords.y, link, ctx, state.globalScale);\n            } else {\n              ctx.beginPath();\n              ctx.arc(coords.x, coords.y, photonR, 0, 2 * Math.PI, false);\n              ctx.fill();\n            }\n          });\n          if (needsCleanup) {\n            // remove expired single hop photons\n            link.__photons = link.__photons.filter(function (photon) {\n              return !photon.__singleHop || photon.__progressRatio <= 1;\n            });\n          }\n        });\n        ctx.restore();\n      }\n    },\n    emitParticle: function emitParticle(state, link) {\n      if (link) {\n        !link.__photons && (link.__photons = []);\n        link.__photons.push({\n          __singleHop: true\n        }); // add a single hop particle\n      }\n      return this;\n    }\n  },\n  stateInit: function stateInit() {\n    return {\n      forceLayout: (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_9__[\"default\"])().force('link', (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_10__[\"default\"])()).force('charge', (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_11__[\"default\"])()).force('center', (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_12__[\"default\"])()).force('dagRadial', null).stop(),\n      engineRunning: false\n    };\n  },\n  init: function init(canvasCtx, state) {\n    // Main canvas object to manipulate\n    state.ctx = canvasCtx;\n  },\n  update: function update(state, changedProps) {\n    state.engineRunning = false; // Pause simulation\n    state.onUpdate();\n    if (state.nodeAutoColorBy !== null) {\n      // Auto add color to uncolored nodes\n      autoColorObjects(state.graphData.nodes, (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeAutoColorBy), state.nodeColor);\n    }\n    if (state.linkAutoColorBy !== null) {\n      // Auto add color to uncolored links\n      autoColorObjects(state.graphData.links, (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkAutoColorBy), state.linkColor);\n    }\n\n    // parse links\n    state.graphData.links.forEach(function (link) {\n      link.source = link[state.linkSource];\n      link.target = link[state.linkTarget];\n    });\n\n    // Feed data to force-directed layout\n    state.forceLayout.stop().alpha(1) // re-heat the simulation\n    .nodes(state.graphData.nodes);\n\n    // add links (if link force is still active)\n    var linkForce = state.forceLayout.force('link');\n    if (linkForce) {\n      linkForce.id(function (d) {\n        return d[state.nodeId];\n      }).links(state.graphData.links);\n    }\n\n    // setup dag force constraints\n    var nodeDepths = state.dagMode && getDagDepths(state.graphData, function (node) {\n      return node[state.nodeId];\n    }, {\n      nodeFilter: state.dagNodeFilter,\n      onLoopError: state.onDagError || undefined\n    });\n    var maxDepth = Math.max.apply(Math, _toConsumableArray(Object.values(nodeDepths || [])));\n    var dagLevelDistance = state.dagLevelDistance || state.graphData.nodes.length / (maxDepth || 1) * DAG_LEVEL_NODE_RATIO * (['radialin', 'radialout'].indexOf(state.dagMode) !== -1 ? 0.7 : 1);\n\n    // Reset relevant fx/fy when swapping dag modes\n    if (['lr', 'rl', 'td', 'bu'].includes(changedProps.dagMode)) {\n      var resetProp = ['lr', 'rl'].includes(changedProps.dagMode) ? 'fx' : 'fy';\n      state.graphData.nodes.filter(state.dagNodeFilter).forEach(function (node) {\n        return delete node[resetProp];\n      });\n    }\n\n    // Fix nodes to x,y for dag mode\n    if (['lr', 'rl', 'td', 'bu'].includes(state.dagMode)) {\n      var invert = ['rl', 'bu'].includes(state.dagMode);\n      var fixFn = function fixFn(node) {\n        return (nodeDepths[node[state.nodeId]] - maxDepth / 2) * dagLevelDistance * (invert ? -1 : 1);\n      };\n      var _resetProp = ['lr', 'rl'].includes(state.dagMode) ? 'fx' : 'fy';\n      state.graphData.nodes.filter(state.dagNodeFilter).forEach(function (node) {\n        return node[_resetProp] = fixFn(node);\n      });\n    }\n\n    // Use radial force for radial dags\n    state.forceLayout.force('dagRadial', ['radialin', 'radialout'].indexOf(state.dagMode) !== -1 ? (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_13__[\"default\"])(function (node) {\n      var nodeDepth = nodeDepths[node[state.nodeId]] || -1;\n      return (state.dagMode === 'radialin' ? maxDepth - nodeDepth : nodeDepth) * dagLevelDistance;\n    }).strength(function (node) {\n      return state.dagNodeFilter(node) ? 1 : 0;\n    }) : null);\n    for (var i = 0; i < state.warmupTicks && !(state.d3AlphaMin > 0 && state.forceLayout.alpha() < state.d3AlphaMin); i++) {\n      state.forceLayout.tick();\n    } // Initial ticks before starting to render\n\n    this.resetCountdown();\n    state.onFinishUpdate();\n  }\n});\n\nfunction linkKapsule (kapsulePropNames, kapsuleType) {\n  var propNames = kapsulePropNames instanceof Array ? kapsulePropNames : [kapsulePropNames];\n  var dummyK = new kapsuleType(); // To extract defaults\n  dummyK._destructor && dummyK._destructor();\n  return {\n    linkProp: function linkProp(prop) {\n      // link property config\n      return {\n        \"default\": dummyK[prop](),\n        onChange: function onChange(v, state) {\n          propNames.forEach(function (propName) {\n            return state[propName][prop](v);\n          });\n        },\n        triggerUpdate: false\n      };\n    },\n    linkMethod: function linkMethod(method) {\n      // link method pass-through\n      return function (state) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        var returnVals = [];\n        propNames.forEach(function (propName) {\n          var kapsuleInstance = state[propName];\n          var returnVal = kapsuleInstance[method].apply(kapsuleInstance, args);\n          if (returnVal !== kapsuleInstance) {\n            returnVals.push(returnVal);\n          }\n        });\n        return returnVals.length ? returnVals[0] : this; // chain based on the parent object, not the inner kapsule\n      };\n    }\n  };\n}\n\nvar HOVER_CANVAS_THROTTLE_DELAY = 800; // ms to throttle shadow canvas updates for perf improvement\nvar ZOOM2NODES_FACTOR = 4;\nvar DRAG_CLICK_TOLERANCE_PX = 5; // How many px can a node be accidentally dragged before disabling the click\n\n// Expose config from forceGraph\nvar bindFG = linkKapsule('forceGraph', CanvasForceGraph);\nvar bindBoth = linkKapsule(['forceGraph', 'shadowGraph'], CanvasForceGraph);\nvar linkedProps = Object.assign.apply(Object, _toConsumableArray(['nodeColor', 'nodeAutoColorBy', 'nodeCanvasObject', 'nodeCanvasObjectMode', 'linkColor', 'linkAutoColorBy', 'linkLineDash', 'linkWidth', 'linkCanvasObject', 'linkCanvasObjectMode', 'linkDirectionalArrowLength', 'linkDirectionalArrowColor', 'linkDirectionalArrowRelPos', 'linkDirectionalParticles', 'linkDirectionalParticleSpeed', 'linkDirectionalParticleOffset', 'linkDirectionalParticleWidth', 'linkDirectionalParticleColor', 'linkDirectionalParticleCanvasObject', 'dagMode', 'dagLevelDistance', 'dagNodeFilter', 'onDagError', 'd3AlphaMin', 'd3AlphaDecay', 'd3VelocityDecay', 'warmupTicks', 'cooldownTicks', 'cooldownTime', 'onEngineTick', 'onEngineStop'].map(function (p) {\n  return _defineProperty({}, p, bindFG.linkProp(p));\n})).concat(_toConsumableArray(['nodeRelSize', 'nodeId', 'nodeVal', 'nodeVisibility', 'linkSource', 'linkTarget', 'linkVisibility', 'linkCurvature'].map(function (p) {\n  return _defineProperty({}, p, bindBoth.linkProp(p));\n}))));\nvar linkedMethods = Object.assign.apply(Object, _toConsumableArray(['d3Force', 'd3ReheatSimulation', 'emitParticle'].map(function (p) {\n  return _defineProperty({}, p, bindFG.linkMethod(p));\n})));\nfunction adjustCanvasSize(state) {\n  if (state.canvas) {\n    var curWidth = state.canvas.width;\n    var curHeight = state.canvas.height;\n    if (curWidth === 300 && curHeight === 150) {\n      // Default canvas dimensions\n      curWidth = curHeight = 0;\n    }\n    var pxScale = window.devicePixelRatio; // 2 on retina displays\n    curWidth /= pxScale;\n    curHeight /= pxScale;\n\n    // Resize canvases\n    [state.canvas, state.shadowCanvas].forEach(function (canvas) {\n      // Element size\n      canvas.style.width = \"\".concat(state.width, \"px\");\n      canvas.style.height = \"\".concat(state.height, \"px\");\n\n      // Memory size (scaled to avoid blurriness)\n      canvas.width = state.width * pxScale;\n      canvas.height = state.height * pxScale;\n\n      // Normalize coordinate system to use css pixels (on init only)\n      if (!curWidth && !curHeight) {\n        canvas.getContext('2d').scale(pxScale, pxScale);\n      }\n    });\n\n    // Relative center panning based on 0,0\n    var k = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k;\n    state.zoom.translateBy(state.zoom.__baseElem, (state.width - curWidth) / 2 / k, (state.height - curHeight) / 2 / k);\n    state.needsRedraw = true;\n  }\n}\nfunction resetTransform(ctx) {\n  var pxRatio = window.devicePixelRatio;\n  ctx.setTransform(pxRatio, 0, 0, pxRatio, 0, 0);\n}\nfunction clearCanvas(ctx, width, height) {\n  ctx.save();\n  resetTransform(ctx); // reset transform\n  ctx.clearRect(0, 0, width, height);\n  ctx.restore(); //restore transforms\n}\n\n//\n\nvar forceGraph = (0,kapsule__WEBPACK_IMPORTED_MODULE_7__[\"default\"])({\n  props: _objectSpread2({\n    width: {\n      \"default\": window.innerWidth,\n      onChange: function onChange(_, state) {\n        return adjustCanvasSize(state);\n      },\n      triggerUpdate: false\n    },\n    height: {\n      \"default\": window.innerHeight,\n      onChange: function onChange(_, state) {\n        return adjustCanvasSize(state);\n      },\n      triggerUpdate: false\n    },\n    graphData: {\n      \"default\": {\n        nodes: [],\n        links: []\n      },\n      onChange: function onChange(d, state) {\n        // Wipe color registry if all objects are new\n        [d.nodes, d.links].every(function (arr) {\n          return (arr || []).every(function (d) {\n            return !d.hasOwnProperty('__indexColor');\n          });\n        }) && state.colorTracker.reset();\n        [{\n          type: 'Node',\n          objs: d.nodes\n        }, {\n          type: 'Link',\n          objs: d.links\n        }].forEach(hexIndex);\n        state.forceGraph.graphData(d);\n        state.shadowGraph.graphData(d);\n        function hexIndex(_ref4) {\n          var type = _ref4.type,\n            objs = _ref4.objs;\n          objs.filter(function (d) {\n            if (!d.hasOwnProperty('__indexColor')) return true;\n            var cur = state.colorTracker.lookup(d.__indexColor);\n            return !cur || !cur.hasOwnProperty('d') || cur.d !== d;\n          }).forEach(function (d) {\n            // store object lookup color\n            d.__indexColor = state.colorTracker.register({\n              type: type,\n              d: d\n            });\n          });\n        }\n      },\n      triggerUpdate: false\n    },\n    backgroundColor: {\n      onChange: function onChange(color, state) {\n        state.canvas && color && (state.canvas.style.background = color);\n      },\n      triggerUpdate: false\n    },\n    nodeLabel: {\n      \"default\": 'name',\n      triggerUpdate: false\n    },\n    nodePointerAreaPaint: {\n      onChange: function onChange(paintFn, state) {\n        state.shadowGraph.nodeCanvasObject(!paintFn ? null : function (node, ctx, globalScale) {\n          return paintFn(node, node.__indexColor, ctx, globalScale);\n        });\n        state.flushShadowCanvas && state.flushShadowCanvas();\n      },\n      triggerUpdate: false\n    },\n    linkPointerAreaPaint: {\n      onChange: function onChange(paintFn, state) {\n        state.shadowGraph.linkCanvasObject(!paintFn ? null : function (link, ctx, globalScale) {\n          return paintFn(link, link.__indexColor, ctx, globalScale);\n        });\n        state.flushShadowCanvas && state.flushShadowCanvas();\n      },\n      triggerUpdate: false\n    },\n    linkLabel: {\n      \"default\": 'name',\n      triggerUpdate: false\n    },\n    linkHoverPrecision: {\n      \"default\": 4,\n      triggerUpdate: false\n    },\n    minZoom: {\n      \"default\": 0.01,\n      onChange: function onChange(minZoom, state) {\n        state.zoom.scaleExtent([minZoom, state.zoom.scaleExtent()[1]]);\n      },\n      triggerUpdate: false\n    },\n    maxZoom: {\n      \"default\": 1000,\n      onChange: function onChange(maxZoom, state) {\n        state.zoom.scaleExtent([state.zoom.scaleExtent()[0], maxZoom]);\n      },\n      triggerUpdate: false\n    },\n    enableNodeDrag: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    enableZoomInteraction: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    enablePanInteraction: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    enableZoomPanInteraction: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    // to be deprecated\n    enablePointerInteraction: {\n      \"default\": true,\n      onChange: function onChange(_, state) {\n        state.hoverObj = null;\n      },\n      triggerUpdate: false\n    },\n    autoPauseRedraw: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    onNodeDrag: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onNodeDragEnd: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onNodeClick: {\n      triggerUpdate: false\n    },\n    onNodeRightClick: {\n      triggerUpdate: false\n    },\n    onNodeHover: {\n      triggerUpdate: false\n    },\n    onLinkClick: {\n      triggerUpdate: false\n    },\n    onLinkRightClick: {\n      triggerUpdate: false\n    },\n    onLinkHover: {\n      triggerUpdate: false\n    },\n    onBackgroundClick: {\n      triggerUpdate: false\n    },\n    onBackgroundRightClick: {\n      triggerUpdate: false\n    },\n    showPointerCursor: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    onZoom: {\n      triggerUpdate: false\n    },\n    onZoomEnd: {\n      triggerUpdate: false\n    },\n    onRenderFramePre: {\n      triggerUpdate: false\n    },\n    onRenderFramePost: {\n      triggerUpdate: false\n    }\n  }, linkedProps),\n  aliases: {\n    // Prop names supported for backwards compatibility\n    stopAnimation: 'pauseAnimation'\n  },\n  methods: _objectSpread2({\n    graph2ScreenCoords: function graph2ScreenCoords(state, x, y) {\n      var t = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas);\n      return {\n        x: x * t.k + t.x,\n        y: y * t.k + t.y\n      };\n    },\n    screen2GraphCoords: function screen2GraphCoords(state, x, y) {\n      var t = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas);\n      return {\n        x: (x - t.x) / t.k,\n        y: (y - t.y) / t.k\n      };\n    },\n    centerAt: function centerAt(state, x, y, transitionDuration) {\n      if (!state.canvas) return null; // no canvas yet\n\n      // setter\n      if (x !== undefined || y !== undefined) {\n        var finalPos = Object.assign({}, x !== undefined ? {\n          x: x\n        } : {}, y !== undefined ? {\n          y: y\n        } : {});\n        if (!transitionDuration) {\n          // no animation\n          setCenter(finalPos);\n        } else {\n          state.tweenGroup.add(new _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Tween(getCenter()).to(finalPos, transitionDuration).easing(_tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Easing.Quadratic.Out).onUpdate(setCenter).start());\n        }\n        return this;\n      }\n\n      // getter\n      return getCenter();\n\n      //\n\n      function getCenter() {\n        var t = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas);\n        return {\n          x: (state.width / 2 - t.x) / t.k,\n          y: (state.height / 2 - t.y) / t.k\n        };\n      }\n      function setCenter(_ref5) {\n        var x = _ref5.x,\n          y = _ref5.y;\n        state.zoom.translateTo(state.zoom.__baseElem, x === undefined ? getCenter().x : x, y === undefined ? getCenter().y : y);\n        state.needsRedraw = true;\n      }\n    },\n    zoom: function zoom(state, k, transitionDuration) {\n      if (!state.canvas) return null; // no canvas yet\n\n      // setter\n      if (k !== undefined) {\n        if (!transitionDuration) {\n          // no animation\n          setZoom(k);\n        } else {\n          state.tweenGroup.add(new _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Tween({\n            k: getZoom()\n          }).to({\n            k: k\n          }, transitionDuration).easing(_tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Easing.Quadratic.Out).onUpdate(function (_ref6) {\n            var k = _ref6.k;\n            return setZoom(k);\n          }).start());\n        }\n        return this;\n      }\n\n      // getter\n      return getZoom();\n\n      //\n\n      function getZoom() {\n        return (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k;\n      }\n      function setZoom(k) {\n        state.zoom.scaleTo(state.zoom.__baseElem, k);\n        state.needsRedraw = true;\n      }\n    },\n    zoomToFit: function zoomToFit(state) {\n      var transitionDuration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n      for (var _len = arguments.length, bboxArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        bboxArgs[_key - 3] = arguments[_key];\n      }\n      var bbox = this.getGraphBbox.apply(this, bboxArgs);\n      if (bbox) {\n        var center = {\n          x: (bbox.x[0] + bbox.x[1]) / 2,\n          y: (bbox.y[0] + bbox.y[1]) / 2\n        };\n        var zoomK = Math.max(1e-12, Math.min(1e12, (state.width - padding * 2) / (bbox.x[1] - bbox.x[0]), (state.height - padding * 2) / (bbox.y[1] - bbox.y[0])));\n        this.centerAt(center.x, center.y, transitionDuration);\n        this.zoom(zoomK, transitionDuration);\n      }\n      return this;\n    },\n    getGraphBbox: function getGraphBbox(state) {\n      var nodeFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return true;\n      };\n      var getVal = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVal);\n      var getR = function getR(node) {\n        return Math.sqrt(Math.max(0, getVal(node) || 1)) * state.nodeRelSize;\n      };\n      var nodesPos = state.graphData.nodes.filter(nodeFilter).map(function (node) {\n        return {\n          x: node.x,\n          y: node.y,\n          r: getR(node)\n        };\n      });\n      return !nodesPos.length ? null : {\n        x: [(0,d3_array__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(nodesPos, function (node) {\n          return node.x - node.r;\n        }), (0,d3_array__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(nodesPos, function (node) {\n          return node.x + node.r;\n        })],\n        y: [(0,d3_array__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(nodesPos, function (node) {\n          return node.y - node.r;\n        }), (0,d3_array__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(nodesPos, function (node) {\n          return node.y + node.r;\n        })]\n      };\n    },\n    pauseAnimation: function pauseAnimation(state) {\n      if (state.animationFrameRequestId) {\n        cancelAnimationFrame(state.animationFrameRequestId);\n        state.animationFrameRequestId = null;\n      }\n      return this;\n    },\n    resumeAnimation: function resumeAnimation(state) {\n      if (!state.animationFrameRequestId) {\n        this._animationCycle();\n      }\n      return this;\n    },\n    _destructor: function _destructor() {\n      this.pauseAnimation();\n      this.graphData({\n        nodes: [],\n        links: []\n      });\n    }\n  }, linkedMethods),\n  stateInit: function stateInit() {\n    return {\n      lastSetZoom: 1,\n      zoom: (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)(),\n      forceGraph: new CanvasForceGraph(),\n      shadowGraph: new CanvasForceGraph().cooldownTicks(0).nodeColor('__indexColor').linkColor('__indexColor').isShadow(true),\n      colorTracker: new canvas_color_tracker__WEBPACK_IMPORTED_MODULE_16__[\"default\"](),\n      // indexed objects for rgb lookup\n      tweenGroup: new _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Group()\n    };\n  },\n  init: function init(domNode, state) {\n    var _this = this;\n    // Wipe DOM\n    domNode.innerHTML = '';\n\n    // Container anchor for canvas and tooltip\n    var container = document.createElement('div');\n    container.classList.add('force-graph-container');\n    container.style.position = 'relative';\n    domNode.appendChild(container);\n    state.canvas = document.createElement('canvas');\n    if (state.backgroundColor) state.canvas.style.background = state.backgroundColor;\n    container.appendChild(state.canvas);\n    state.shadowCanvas = document.createElement('canvas');\n\n    // Show shadow canvas\n    //state.shadowCanvas.style.position = 'absolute';\n    //state.shadowCanvas.style.top = '0';\n    //state.shadowCanvas.style.left = '0';\n    //container.appendChild(state.shadowCanvas);\n\n    var ctx = state.canvas.getContext('2d');\n    var shadowCtx = state.shadowCanvas.getContext('2d', {\n      willReadFrequently: true\n    });\n    var pointerPos = {\n      x: -1e12,\n      y: -1e12\n    };\n    var getObjUnderPointer = function getObjUnderPointer() {\n      var obj = null;\n      var pxScale = window.devicePixelRatio;\n      var px = pointerPos.x > 0 && pointerPos.y > 0 ? shadowCtx.getImageData(pointerPos.x * pxScale, pointerPos.y * pxScale, 1, 1) : null;\n      // Lookup object per pixel color\n      px && (obj = state.colorTracker.lookup(px.data));\n      return obj;\n    };\n\n    // Setup node drag interaction\n    (0,d3_selection__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(state.canvas).call((0,d3_drag__WEBPACK_IMPORTED_MODULE_18__[\"default\"])().subject(function () {\n      if (!state.enableNodeDrag) {\n        return null;\n      }\n      var obj = getObjUnderPointer();\n      return obj && obj.type === 'Node' ? obj.d : null; // Only drag nodes\n    }).on('start', function (ev) {\n      var obj = ev.subject;\n      obj.__initialDragPos = {\n        x: obj.x,\n        y: obj.y,\n        fx: obj.fx,\n        fy: obj.fy\n      };\n\n      // keep engine running at low intensity throughout drag\n      if (!ev.active) {\n        obj.fx = obj.x;\n        obj.fy = obj.y; // Fix points\n      }\n\n      // drag cursor\n      state.canvas.classList.add('grabbable');\n    }).on('drag', function (ev) {\n      var obj = ev.subject;\n      var initPos = obj.__initialDragPos;\n      var dragPos = ev;\n      var k = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k;\n      var translate = {\n        x: initPos.x + (dragPos.x - initPos.x) / k - obj.x,\n        y: initPos.y + (dragPos.y - initPos.y) / k - obj.y\n      };\n\n      // Move fx/fy (and x/y) of nodes based on the scaled drag distance since the drag start\n      ['x', 'y'].forEach(function (c) {\n        return obj[\"f\".concat(c)] = obj[c] = initPos[c] + (dragPos[c] - initPos[c]) / k;\n      });\n\n      // Only engage full drag if distance reaches above threshold\n      if (!obj.__dragged && DRAG_CLICK_TOLERANCE_PX >= Math.sqrt((0,d3_array__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(['x', 'y'].map(function (k) {\n        return Math.pow(ev[k] - initPos[k], 2);\n      })))) return;\n      state.forceGraph.d3AlphaTarget(0.3) // keep engine running at low intensity throughout drag\n      .resetCountdown(); // prevent freeze while dragging\n\n      state.isPointerDragging = true;\n      obj.__dragged = true;\n      state.onNodeDrag(obj, translate);\n    }).on('end', function (ev) {\n      var obj = ev.subject;\n      var initPos = obj.__initialDragPos;\n      var translate = {\n        x: obj.x - initPos.x,\n        y: obj.y - initPos.y\n      };\n      if (initPos.fx === undefined) {\n        obj.fx = undefined;\n      }\n      if (initPos.fy === undefined) {\n        obj.fy = undefined;\n      }\n      delete obj.__initialDragPos;\n      if (state.forceGraph.d3AlphaTarget()) {\n        state.forceGraph.d3AlphaTarget(0) // release engine low intensity\n        .resetCountdown(); // let the engine readjust after releasing fixed nodes\n      }\n\n      // drag cursor\n      state.canvas.classList.remove('grabbable');\n      state.isPointerDragging = false;\n      if (obj.__dragged) {\n        delete obj.__dragged;\n        state.onNodeDragEnd(obj, translate);\n      }\n    }));\n\n    // Setup zoom / pan interaction\n    state.zoom(state.zoom.__baseElem = (0,d3_selection__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(state.canvas)); // Attach controlling elem for easy access\n\n    state.zoom.__baseElem.on('dblclick.zoom', null); // Disable double-click to zoom\n\n    state.zoom.filter(function (ev) {\n      return (\n        // disable zoom interaction\n        !ev.button && state.enableZoomPanInteraction && (ev.type !== 'wheel' || (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.enableZoomInteraction)(ev)) && (ev.type === 'wheel' || (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.enablePanInteraction)(ev))\n      );\n    }).on('zoom', function (ev) {\n      var t = ev.transform;\n      [ctx, shadowCtx].forEach(function (c) {\n        resetTransform(c);\n        c.translate(t.x, t.y);\n        c.scale(t.k, t.k);\n      });\n      state.isPointerDragging = true;\n      state.onZoom && state.onZoom(_objectSpread2(_objectSpread2({}, t), _this.centerAt())); // report x,y coordinates relative to canvas center\n      state.needsRedraw = true;\n    }).on('end', function (ev) {\n      state.isPointerDragging = false;\n      state.onZoomEnd && state.onZoomEnd(_objectSpread2(_objectSpread2({}, ev.transform), _this.centerAt()));\n    });\n    adjustCanvasSize(state);\n    state.forceGraph.onNeedsRedraw(function () {\n      return state.needsRedraw = true;\n    }).onFinishUpdate(function () {\n      // re-zoom, if still in default position (not user modified)\n      if ((0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k === state.lastSetZoom && state.graphData.nodes.length) {\n        state.zoom.scaleTo(state.zoom.__baseElem, state.lastSetZoom = ZOOM2NODES_FACTOR / Math.cbrt(state.graphData.nodes.length));\n        state.needsRedraw = true;\n      }\n    });\n\n    // Setup tooltip\n    state.tooltip = new float_tooltip__WEBPACK_IMPORTED_MODULE_3__[\"default\"](container);\n\n    // Capture pointer coords on move or touchstart\n    ['pointermove', 'pointerdown'].forEach(function (evType) {\n      return container.addEventListener(evType, function (ev) {\n        if (evType === 'pointerdown') {\n          state.isPointerPressed = true; // track click state\n          state.pointerDownEvent = ev;\n        }\n\n        // detect pointer drag on canvas pan\n        !state.isPointerDragging && ev.type === 'pointermove' && state.onBackgroundClick // only bother detecting drags this way if background clicks are enabled (so they don't trigger accidentally on canvas panning)\n        && (ev.pressure > 0 || state.isPointerPressed) // ev.pressure always 0 on Safari, so we use the isPointerPressed tracker\n        && (ev.pointerType === 'mouse' || ev.movementX === undefined || [ev.movementX, ev.movementY].some(function (m) {\n          return Math.abs(m) > 1;\n        })) // relax drag trigger sensitivity on non-mouse (touch/pen) events\n        && (state.isPointerDragging = true);\n\n        // update the pointer pos\n        var offset = getOffset(container);\n        pointerPos.x = ev.pageX - offset.left;\n        pointerPos.y = ev.pageY - offset.top;\n\n        //\n\n        function getOffset(el) {\n          var rect = el.getBoundingClientRect(),\n            scrollLeft = window.pageXOffset || document.documentElement.scrollLeft,\n            scrollTop = window.pageYOffset || document.documentElement.scrollTop;\n          return {\n            top: rect.top + scrollTop,\n            left: rect.left + scrollLeft\n          };\n        }\n      }, {\n        passive: true\n      });\n    });\n\n    // Handle click/touch events on nodes/links\n    container.addEventListener('pointerup', function (ev) {\n      if (!state.isPointerPressed) {\n        return; // don't trigger click events if pointer is not pressed on the canvas\n      }\n      state.isPointerPressed = false;\n      if (state.isPointerDragging) {\n        state.isPointerDragging = false;\n        return; // don't trigger click events after pointer drag (pan / node drag functionality)\n      }\n      var cbEvents = [ev, state.pointerDownEvent];\n      requestAnimationFrame(function () {\n        // trigger click events asynchronously, to allow hoverObj to be set (on frame)\n        if (ev.button === 0) {\n          // mouse left-click or touch\n          if (state.hoverObj) {\n            var fn = state[\"on\".concat(state.hoverObj.type, \"Click\")];\n            fn && fn.apply(void 0, [state.hoverObj.d].concat(cbEvents));\n          } else {\n            state.onBackgroundClick && state.onBackgroundClick.apply(state, cbEvents);\n          }\n        }\n        if (ev.button === 2) {\n          // mouse right-click\n          if (state.hoverObj) {\n            var _fn = state[\"on\".concat(state.hoverObj.type, \"RightClick\")];\n            _fn && _fn.apply(void 0, [state.hoverObj.d].concat(cbEvents));\n          } else {\n            state.onBackgroundRightClick && state.onBackgroundRightClick.apply(state, cbEvents);\n          }\n        }\n      });\n    }, {\n      passive: true\n    });\n    container.addEventListener('contextmenu', function (ev) {\n      if (!state.onBackgroundRightClick && !state.onNodeRightClick && !state.onLinkRightClick) return true; // default contextmenu behavior\n      ev.preventDefault();\n      return false;\n    });\n    state.forceGraph(ctx);\n    state.shadowGraph(shadowCtx);\n\n    //\n\n    var refreshShadowCanvas = (0,lodash_es__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(function () {\n      // wipe canvas\n      clearCanvas(shadowCtx, state.width, state.height);\n\n      // Adjust link hover area\n      state.shadowGraph.linkWidth(function (l) {\n        return (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkWidth)(l) + state.linkHoverPrecision;\n      });\n\n      // redraw\n      var t = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas);\n      state.shadowGraph.globalScale(t.k).tickFrame();\n    }, HOVER_CANVAS_THROTTLE_DELAY);\n    state.flushShadowCanvas = refreshShadowCanvas.flush; // hook to immediately invoke shadow canvas paint\n\n    // Kick-off renderer\n    (this._animationCycle = function animate() {\n      // IIFE\n      var doRedraw = !state.autoPauseRedraw || !!state.needsRedraw || state.forceGraph.isEngineRunning() || state.graphData.links.some(function (d) {\n        return d.__photons && d.__photons.length;\n      });\n      state.needsRedraw = false;\n      if (state.enablePointerInteraction) {\n        // Update tooltip and trigger onHover events\n        var obj = !state.isPointerDragging ? getObjUnderPointer() : null; // don't hover during drag\n        if (obj !== state.hoverObj) {\n          var prevObj = state.hoverObj;\n          var prevObjType = prevObj ? prevObj.type : null;\n          var objType = obj ? obj.type : null;\n          if (prevObjType && prevObjType !== objType) {\n            // Hover out\n            var fn = state[\"on\".concat(prevObjType, \"Hover\")];\n            fn && fn(null, prevObj.d);\n          }\n          if (objType) {\n            // Hover in\n            var _fn2 = state[\"on\".concat(objType, \"Hover\")];\n            _fn2 && _fn2(obj.d, prevObjType === objType ? prevObj.d : null);\n          }\n          state.tooltip.content(obj ? (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state[\"\".concat(obj.type.toLowerCase(), \"Label\")])(obj.d) || null : null);\n\n          // set pointer if hovered object is clickable\n          state.canvas.classList[(obj && state[\"on\".concat(objType, \"Click\")] || !obj && state.onBackgroundClick) && (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.showPointerCursor)(obj === null || obj === void 0 ? void 0 : obj.d) ? 'add' : 'remove']('clickable');\n          state.hoverObj = obj;\n        }\n        doRedraw && refreshShadowCanvas();\n      }\n      if (doRedraw) {\n        // Wipe canvas\n        clearCanvas(ctx, state.width, state.height);\n\n        // Frame cycle\n        var globalScale = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k;\n        state.onRenderFramePre && state.onRenderFramePre(ctx, globalScale);\n        state.forceGraph.globalScale(globalScale).tickFrame();\n        state.onRenderFramePost && state.onRenderFramePost(ctx, globalScale);\n      }\n      state.tweenGroup.update(); // update canvas animation tweens\n\n      state.animationFrameRequestId = requestAnimationFrame(animate);\n    })();\n  },\n  update: function updateFn(state) {}\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZm9yY2UtZ3JhcGgvZGlzdC9mb3JjZS1ncmFwaC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzQztBQUNRO0FBQ2Y7QUFDVTtBQUNKO0FBQ29CO0FBQzNCO0FBQ087QUFDVztBQUNaO0FBQzhEO0FBQy9EO0FBQ0U7QUFDRztBQUNVOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLG1CQUFtQixzQkFBc0Isa0JBQWtCLDZDQUE2QyxHQUFHLHVDQUF1QyxvQkFBb0IsR0FBRyx1Q0FBdUMsaUJBQWlCLGlCQUFpQixzQkFBc0IseUJBQXlCLEdBQUcsOENBQThDLHFCQUFxQiwwQkFBMEIsNkJBQTZCLEdBQUc7QUFDaGQ7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekYsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVksa0VBQWtFO0FBQzdILE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsWUFBWTtBQUNaLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVEQUFVO0FBQ3RDLHFCQUFxQix1REFBVTtBQUMvQix1QkFBdUIsdURBQVU7QUFDakMsc0NBQXNDLHVEQUFVO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVEQUFVO0FBQ3RDLHVCQUF1Qix1REFBVTtBQUNqQyx1QkFBdUIsdURBQVU7QUFDakMsMEJBQTBCLHVEQUFVO0FBQ3BDLDJCQUEyQix1REFBVTtBQUNyQyxzQ0FBc0MsdURBQVU7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSw0QkFBNEIsMERBQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRzs7QUFFdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7O0FBRWhHLDBGQUEwRjs7QUFFMUY7QUFDQSxrRUFBa0U7QUFDbEUsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVEQUFVO0FBQ2xDLHdCQUF3Qix1REFBVTtBQUNsQyw0QkFBNEIsdURBQVU7QUFDdEMsdUJBQXVCLHVEQUFVO0FBQ2pDLHlCQUF5Qix1REFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRzs7QUFFaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRCw2Q0FBTTtBQUNoRTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVEQUFVO0FBQ3RDLHVCQUF1Qix1REFBVTtBQUNqQyx3QkFBd0IsdURBQVU7QUFDbEMsMEJBQTBCLHVEQUFVO0FBQ3BDLDRCQUE0Qix1REFBVTtBQUN0Qyx1QkFBdUIsdURBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7O0FBRWhHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RCw2Q0FBTTtBQUMvRDtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQix1REFBZSxpQkFBaUIsd0RBQVMsb0JBQW9CLHdEQUFhLG9CQUFvQix3REFBVztBQUM1SDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdURBQVU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVEQUFVO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsbUdBQW1HLHdEQUFXO0FBQzlHO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLGtHQUFrRztBQUN0SDtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsYUFBYTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsQ0FBQztBQUNELDJCQUEyQjtBQUMzQixDQUFDO0FBQ0Q7QUFDQSwyQkFBMkI7QUFDM0IsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxZQUFZLHNEQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBOztBQUVBLGlCQUFpQixtREFBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGNBQWMsc0RBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjLHNEQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsVUFBVSxJQUFJO0FBQ2Q7QUFDQSxVQUFVLElBQUk7QUFDZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsbUNBQW1DLG9EQUFLLHNEQUFzRCxxREFBTTtBQUNwRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQixzREFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLG1DQUFtQyxvREFBSztBQUN4QztBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVcsNkJBQTZCLHFEQUFNO0FBQzlDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxlQUFlLHNEQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLGFBQWE7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdURBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsWUFBWSxxREFBRztBQUNmO0FBQ0EsU0FBUyxHQUFHLHFEQUFHO0FBQ2Y7QUFDQSxTQUFTO0FBQ1QsWUFBWSxxREFBRztBQUNmO0FBQ0EsU0FBUyxHQUFHLHFEQUFHO0FBQ2Y7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZDQUFJO0FBQ2hCO0FBQ0E7QUFDQSx3QkFBd0IsNkRBQVk7QUFDcEM7QUFDQSxzQkFBc0Isb0RBQUs7QUFDM0I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUkseURBQU0sb0JBQW9CLG9EQUFJO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNEQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxpRUFBaUUscURBQUc7QUFDcEU7QUFDQSxPQUFPO0FBQ1A7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsdUNBQXVDLHlEQUFNLGlCQUFpQjs7QUFFOUQscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsdURBQVUsOERBQThELHVEQUFVO0FBQ2xLO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxtRUFBbUUsMEJBQTBCO0FBQzdGO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUVBQXlFO0FBQ3pFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxVQUFVLHNEQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSx3QkFBd0IscURBQU87O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLDRHQUE0RztBQUM1RztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUEsOEJBQThCLHNEQUFRO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsdURBQVU7QUFDekIsT0FBTzs7QUFFUDtBQUNBLGNBQWMsc0RBQWE7QUFDM0I7QUFDQSxLQUFLO0FBQ0wseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHVEQUFVOztBQUVoRDtBQUNBLHFIQUFxSCx1REFBVTtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixzREFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFZ0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmlhbnZhbmNlL2J2YW5jZWpyL2dpdC93ZWRkaW5nLWd1ZXN0LW1hbmFnZXIvbm9kZV9tb2R1bGVzL2ZvcmNlLWdyYXBoL2Rpc3QvZm9yY2UtZ3JhcGgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbic7XG5pbXBvcnQgeyB6b29tVHJhbnNmb3JtLCB6b29tIH0gZnJvbSAnZDMtem9vbSc7XG5pbXBvcnQgeyBkcmFnIH0gZnJvbSAnZDMtZHJhZyc7XG5pbXBvcnQgeyBzdW0sIG1pbiwgbWF4IH0gZnJvbSAnZDMtYXJyYXknO1xuaW1wb3J0IHsgdGhyb3R0bGUgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgR3JvdXAsIFR3ZWVuLCBFYXNpbmcgfSBmcm9tICdAdHdlZW5qcy90d2Vlbi5qcyc7XG5pbXBvcnQgS2Fwc3VsZSBmcm9tICdrYXBzdWxlJztcbmltcG9ydCBhY2Nlc3NvckZuIGZyb20gJ2FjY2Vzc29yLWZuJztcbmltcG9ydCBDb2xvclRyYWNrZXIgZnJvbSAnY2FudmFzLWNvbG9yLXRyYWNrZXInO1xuaW1wb3J0IFRvb2x0aXAgZnJvbSAnZmxvYXQtdG9vbHRpcCc7XG5pbXBvcnQgeyBmb3JjZVJhZGlhbCwgZm9yY2VTaW11bGF0aW9uLCBmb3JjZUxpbmssIGZvcmNlTWFueUJvZHksIGZvcmNlQ2VudGVyIH0gZnJvbSAnZDMtZm9yY2UtM2QnO1xuaW1wb3J0IHsgQmV6aWVyIH0gZnJvbSAnYmV6aWVyLWpzJztcbmltcG9ydCBpbmRleEJ5IGZyb20gJ2luZGV4LWFycmF5LWJ5JztcbmltcG9ydCB7IHNjYWxlT3JkaW5hbCB9IGZyb20gJ2QzLXNjYWxlJztcbmltcG9ydCB7IHNjaGVtZVBhaXJlZCB9IGZyb20gJ2QzLXNjYWxlLWNocm9tYXRpYyc7XG5cbmZ1bmN0aW9uIHN0eWxlSW5qZWN0KGNzcywgcmVmKSB7XG4gIGlmIChyZWYgPT09IHZvaWQgMCkgcmVmID0ge307XG4gIHZhciBpbnNlcnRBdCA9IHJlZi5pbnNlcnRBdDtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuICBpZiAoaW5zZXJ0QXQgPT09ICd0b3AnKSB7XG4gICAgaWYgKGhlYWQuZmlyc3RDaGlsZCkge1xuICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGUsIGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgY3NzXzI0OHogPSBcIi5mb3JjZS1ncmFwaC1jb250YWluZXIgY2FudmFzIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICBvdXRsaW5lOiBub25lO1xcbiAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcXG59XFxuXFxuLmZvcmNlLWdyYXBoLWNvbnRhaW5lciAuY2xpY2thYmxlIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLmZvcmNlLWdyYXBoLWNvbnRhaW5lciAuZ3JhYmJhYmxlIHtcXG4gIGN1cnNvcjogbW92ZTtcXG4gIGN1cnNvcjogZ3JhYjtcXG4gIGN1cnNvcjogLW1vei1ncmFiO1xcbiAgY3Vyc29yOiAtd2Via2l0LWdyYWI7XFxufVxcblxcbi5mb3JjZS1ncmFwaC1jb250YWluZXIgLmdyYWJiYWJsZTphY3RpdmUge1xcbiAgY3Vyc29yOiBncmFiYmluZztcXG4gIGN1cnNvcjogLW1vei1ncmFiYmluZztcXG4gIGN1cnNvcjogLXdlYmtpdC1ncmFiYmluZztcXG59XFxuXCI7XG5zdHlsZUluamVjdChjc3NfMjQ4eik7XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHtcbiAgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpO1xuICBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMocikge1xuICBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMocikge1xuICBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIpO1xufVxuZnVuY3Rpb24gX2NvbnN0cnVjdCh0LCBlLCByKSB7XG4gIGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB2YXIgbyA9IFtudWxsXTtcbiAgby5wdXNoLmFwcGx5KG8sIGUpO1xuICB2YXIgcCA9IG5ldyAodC5iaW5kLmFwcGx5KHQsIG8pKSgpO1xuICByZXR1cm4gcDtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7XG4gIHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcbiAgICB2YWx1ZTogdCxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSA6IGVbcl0gPSB0LCBlO1xufVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gIH0gY2F0Y2ggKHQpIHt9XG4gIHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0O1xuICB9KSgpO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShyKSB7XG4gIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgbnVsbCAhPSByW1N5bWJvbC5pdGVyYXRvcl0gfHwgbnVsbCAhPSByW1wiQEBpdGVyYXRvclwiXSkgcmV0dXJuIEFycmF5LmZyb20ocik7XG59XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkge1xuICB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAobnVsbCAhPSB0KSB7XG4gICAgdmFyIGUsXG4gICAgICBuLFxuICAgICAgaSxcbiAgICAgIHUsXG4gICAgICBhID0gW10sXG4gICAgICBmID0gdHJ1ZSxcbiAgICAgIG8gPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgOyBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIG8gPSB0cnVlLCBuID0gcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFmICYmIG51bGwgIT0gdC5yZXR1cm4gJiYgKHUgPSB0LnJldHVybigpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAobykgdGhyb3cgbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cbn1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7XG4gIHZhciB0ID0gT2JqZWN0LmtleXMoZSk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTtcbiAgICB9KSksIHQucHVzaC5hcHBseSh0LCBvKTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKGUpIHtcbiAgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHtcbiAgICB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307XG4gICAgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkociwgZSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBlKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgZSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KHIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5KHIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjtcbn1cbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIF90eXBlb2Yobyk7XG59XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkge1xuICBpZiAocikge1xuICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7XG4gICAgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTtcbiAgICByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSA6IHZvaWQgMDtcbiAgfVxufVxuXG52YXIgYXV0b0NvbG9yU2NhbGUgPSBzY2FsZU9yZGluYWwoc2NoZW1lUGFpcmVkKTtcblxuLy8gQXV0b3NldCBhdHRyaWJ1dGUgY29sb3JGaWVsZCBieSBjb2xvckJ5QWNjZXNzb3IgcHJvcGVydHlcbi8vIElmIGFuIG9iamVjdCBoYXMgYWxyZWFkeSBhIGNvbG9yLCBkb24ndCBzZXQgaXRcbi8vIE9iamVjdHMgY2FuIGJlIG5vZGVzIG9yIGxpbmtzXG5mdW5jdGlvbiBhdXRvQ29sb3JPYmplY3RzKG9iamVjdHMsIGNvbG9yQnlBY2Nlc3NvciwgY29sb3JGaWVsZCkge1xuICBpZiAoIWNvbG9yQnlBY2Nlc3NvciB8fCB0eXBlb2YgY29sb3JGaWVsZCAhPT0gJ3N0cmluZycpIHJldHVybjtcbiAgb2JqZWN0cy5maWx0ZXIoZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiAhb2JqW2NvbG9yRmllbGRdO1xuICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICBvYmpbY29sb3JGaWVsZF0gPSBhdXRvQ29sb3JTY2FsZShjb2xvckJ5QWNjZXNzb3Iob2JqKSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXREYWdEZXB0aHMgKF9yZWYsIGlkQWNjZXNzb3IpIHtcbiAgdmFyIG5vZGVzID0gX3JlZi5ub2RlcyxcbiAgICBsaW5rcyA9IF9yZWYubGlua3M7XG4gIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge30sXG4gICAgX3JlZjIkbm9kZUZpbHRlciA9IF9yZWYyLm5vZGVGaWx0ZXIsXG4gICAgbm9kZUZpbHRlciA9IF9yZWYyJG5vZGVGaWx0ZXIgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gOiBfcmVmMiRub2RlRmlsdGVyLFxuICAgIF9yZWYyJG9uTG9vcEVycm9yID0gX3JlZjIub25Mb29wRXJyb3IsXG4gICAgb25Mb29wRXJyb3IgPSBfcmVmMiRvbkxvb3BFcnJvciA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKGxvb3BJZHMpIHtcbiAgICAgIHRocm93IFwiSW52YWxpZCBEQUcgc3RydWN0dXJlISBGb3VuZCBjeWNsZSBpbiBub2RlIHBhdGg6IFwiLmNvbmNhdChsb29wSWRzLmpvaW4oJyAtPiAnKSwgXCIuXCIpO1xuICAgIH0gOiBfcmVmMiRvbkxvb3BFcnJvcjtcbiAgLy8gbGlua2VkIGdyYXBoXG4gIHZhciBncmFwaCA9IHt9O1xuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIGdyYXBoW2lkQWNjZXNzb3Iobm9kZSldID0ge1xuICAgICAgZGF0YTogbm9kZSxcbiAgICAgIG91dDogW10sXG4gICAgICBkZXB0aDogLTEsXG4gICAgICBza2lwOiAhbm9kZUZpbHRlcihub2RlKVxuICAgIH07XG4gIH0pO1xuICBsaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMykge1xuICAgIHZhciBzb3VyY2UgPSBfcmVmMy5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmMy50YXJnZXQ7XG4gICAgdmFyIHNvdXJjZUlkID0gZ2V0Tm9kZUlkKHNvdXJjZSk7XG4gICAgdmFyIHRhcmdldElkID0gZ2V0Tm9kZUlkKHRhcmdldCk7XG4gICAgaWYgKCFncmFwaC5oYXNPd25Qcm9wZXJ0eShzb3VyY2VJZCkpIHRocm93IFwiTWlzc2luZyBzb3VyY2Ugbm9kZSB3aXRoIGlkOiBcIi5jb25jYXQoc291cmNlSWQpO1xuICAgIGlmICghZ3JhcGguaGFzT3duUHJvcGVydHkodGFyZ2V0SWQpKSB0aHJvdyBcIk1pc3NpbmcgdGFyZ2V0IG5vZGUgd2l0aCBpZDogXCIuY29uY2F0KHRhcmdldElkKTtcbiAgICB2YXIgc291cmNlTm9kZSA9IGdyYXBoW3NvdXJjZUlkXTtcbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IGdyYXBoW3RhcmdldElkXTtcbiAgICBzb3VyY2VOb2RlLm91dC5wdXNoKHRhcmdldE5vZGUpO1xuICAgIGZ1bmN0aW9uIGdldE5vZGVJZChub2RlKSB7XG4gICAgICByZXR1cm4gX3R5cGVvZihub2RlKSA9PT0gJ29iamVjdCcgPyBpZEFjY2Vzc29yKG5vZGUpIDogbm9kZTtcbiAgICB9XG4gIH0pO1xuICB2YXIgZm91bmRMb29wcyA9IFtdO1xuICB0cmF2ZXJzZShPYmplY3QudmFsdWVzKGdyYXBoKSk7XG4gIHZhciBub2RlRGVwdGhzID0gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIFt7fV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShPYmplY3QuZW50cmllcyhncmFwaCkuZmlsdGVyKGZ1bmN0aW9uIChfcmVmNCkge1xuICAgIHZhciBfcmVmNSA9IF9zbGljZWRUb0FycmF5KF9yZWY0LCAyKSxcbiAgICAgIG5vZGUgPSBfcmVmNVsxXTtcbiAgICByZXR1cm4gIW5vZGUuc2tpcDtcbiAgfSkubWFwKGZ1bmN0aW9uIChfcmVmNikge1xuICAgIHZhciBfcmVmNyA9IF9zbGljZWRUb0FycmF5KF9yZWY2LCAyKSxcbiAgICAgIGlkID0gX3JlZjdbMF0sXG4gICAgICBub2RlID0gX3JlZjdbMV07XG4gICAgcmV0dXJuIF9kZWZpbmVQcm9wZXJ0eSh7fSwgaWQsIG5vZGUuZGVwdGgpO1xuICB9KSkpKTtcbiAgcmV0dXJuIG5vZGVEZXB0aHM7XG4gIGZ1bmN0aW9uIHRyYXZlcnNlKG5vZGVzKSB7XG4gICAgdmFyIG5vZGVTdGFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgdmFyIGN1cnJlbnREZXB0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICBpZiAobm9kZVN0YWNrLmluZGV4T2Yobm9kZSkgIT09IC0xKSB7XG4gICAgICAgIHZhciBsb29wID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShub2RlU3RhY2suc2xpY2Uobm9kZVN0YWNrLmluZGV4T2Yobm9kZSkpKSwgW25vZGVdKS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gaWRBY2Nlc3NvcihkLmRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFmb3VuZExvb3BzLnNvbWUoZnVuY3Rpb24gKGZvdW5kTG9vcCkge1xuICAgICAgICAgIHJldHVybiBmb3VuZExvb3AubGVuZ3RoID09PSBsb29wLmxlbmd0aCAmJiBmb3VuZExvb3AuZXZlcnkoZnVuY3Rpb24gKGlkLCBpZHgpIHtcbiAgICAgICAgICAgIHJldHVybiBpZCA9PT0gbG9vcFtpZHhdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIGZvdW5kTG9vcHMucHVzaChsb29wKTtcbiAgICAgICAgICBvbkxvb3BFcnJvcihsb29wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTsgLy8gY29udGludWVcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50RGVwdGggPiBub2RlLmRlcHRoKSB7XG4gICAgICAgIC8vIERvbid0IHVubmVjZXNzYXJpbHkgcmV2aXNpdCBjaHVua3Mgb2YgdGhlIGdyYXBoXG4gICAgICAgIG5vZGUuZGVwdGggPSBjdXJyZW50RGVwdGg7XG4gICAgICAgIHRyYXZlcnNlKG5vZGUub3V0LCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG5vZGVTdGFjayksIFtub2RlXSksIGN1cnJlbnREZXB0aCArIChub2RlLnNraXAgPyAwIDogMSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChfbG9vcCgpKSBjb250aW51ZTtcbiAgICB9XG4gIH1cbn1cblxuLy9cblxudmFyIERBR19MRVZFTF9OT0RFX1JBVElPID0gMjtcblxuLy8gd2hlbmV2ZXIgc3R5bGluZyBwcm9wcyBhcmUgY2hhbmdlZCB0aGF0IHJlcXVpcmUgYSBjYW52YXMgcmVkcmF3XG52YXIgbm90aWZ5UmVkcmF3ID0gZnVuY3Rpb24gbm90aWZ5UmVkcmF3KF8sIHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5vbk5lZWRzUmVkcmF3ICYmIHN0YXRlLm9uTmVlZHNSZWRyYXcoKTtcbn07XG52YXIgdXBkRGF0YVBob3RvbnMgPSBmdW5jdGlvbiB1cGREYXRhUGhvdG9ucyhfLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLmlzU2hhZG93KSB7XG4gICAgLy8gQWRkIHBob3RvbiBwYXJ0aWNsZXNcbiAgICB2YXIgbGlua1BhcnRpY2xlc0FjY2Vzc29yID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rRGlyZWN0aW9uYWxQYXJ0aWNsZXMpO1xuICAgIHN0YXRlLmdyYXBoRGF0YS5saW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICB2YXIgbnVtUGhvdG9ucyA9IE1hdGgucm91bmQoTWF0aC5hYnMobGlua1BhcnRpY2xlc0FjY2Vzc29yKGxpbmspKSk7XG4gICAgICBpZiAobnVtUGhvdG9ucykge1xuICAgICAgICBsaW5rLl9fcGhvdG9ucyA9IF90b0NvbnN1bWFibGVBcnJheShBcnJheShudW1QaG90b25zKSkubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGxpbmsuX19waG90b25zO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xudmFyIENhbnZhc0ZvcmNlR3JhcGggPSBLYXBzdWxlKHtcbiAgcHJvcHM6IHtcbiAgICBncmFwaERhdGE6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgIG5vZGVzOiBbXSxcbiAgICAgICAgbGlua3M6IFtdXG4gICAgICB9LFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKF8sIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLmVuZ2luZVJ1bm5pbmcgPSBmYWxzZTsgLy8gUGF1c2Ugc2ltdWxhdGlvblxuICAgICAgICB1cGREYXRhUGhvdG9ucyhfLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkYWdNb2RlOiB7XG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoZGFnTW9kZSwgc3RhdGUpIHtcbiAgICAgICAgLy8gdGQsIGJ1LCBsciwgcmwsIHJhZGlhbGluLCByYWRpYWxvdXRcbiAgICAgICAgIWRhZ01vZGUgJiYgKHN0YXRlLmdyYXBoRGF0YS5ub2RlcyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICAgIHJldHVybiBuLmZ4ID0gbi5meSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7IC8vIHVuZml4IG5vZGVzIHdoZW4gZGlzYWJsaW5nIGRhZyBtb2RlXG4gICAgICB9XG4gICAgfSxcbiAgICBkYWdMZXZlbERpc3RhbmNlOiB7fSxcbiAgICBkYWdOb2RlRmlsdGVyOiB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQobm9kZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uRGFnRXJyb3I6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBub2RlUmVsU2l6ZToge1xuICAgICAgXCJkZWZhdWx0XCI6IDQsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub3RpZnlSZWRyYXdcbiAgICB9LFxuICAgIC8vIGFyZWEgcGVyIHZhbCB1bml0XG4gICAgbm9kZUlkOiB7XG4gICAgICBcImRlZmF1bHRcIjogJ2lkJ1xuICAgIH0sXG4gICAgbm9kZVZhbDoge1xuICAgICAgXCJkZWZhdWx0XCI6ICd2YWwnLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBub2RlQ29sb3I6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAnY29sb3InLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBub2RlQXV0b0NvbG9yQnk6IHt9LFxuICAgIG5vZGVDYW52YXNPYmplY3Q6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbm9kZUNhbnZhc09iamVjdE1vZGU6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuICdyZXBsYWNlJztcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub3RpZnlSZWRyYXdcbiAgICB9LFxuICAgIG5vZGVWaXNpYmlsaXR5OiB7XG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbGlua1NvdXJjZToge1xuICAgICAgXCJkZWZhdWx0XCI6ICdzb3VyY2UnXG4gICAgfSxcbiAgICBsaW5rVGFyZ2V0OiB7XG4gICAgICBcImRlZmF1bHRcIjogJ3RhcmdldCdcbiAgICB9LFxuICAgIGxpbmtWaXNpYmlsaXR5OiB7XG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbGlua0NvbG9yOiB7XG4gICAgICBcImRlZmF1bHRcIjogJ2NvbG9yJyxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbGlua0F1dG9Db2xvckJ5OiB7fSxcbiAgICBsaW5rTGluZURhc2g6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbGlua1dpZHRoOiB7XG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbGlua0N1cnZhdHVyZToge1xuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub3RpZnlSZWRyYXdcbiAgICB9LFxuICAgIGxpbmtDYW52YXNPYmplY3Q6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbGlua0NhbnZhc09iamVjdE1vZGU6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuICdyZXBsYWNlJztcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub3RpZnlSZWRyYXdcbiAgICB9LFxuICAgIGxpbmtEaXJlY3Rpb25hbEFycm93TGVuZ3RoOiB7XG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbGlua0RpcmVjdGlvbmFsQXJyb3dDb2xvcjoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBsaW5rRGlyZWN0aW9uYWxBcnJvd1JlbFBvczoge1xuICAgICAgXCJkZWZhdWx0XCI6IDAuNSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgLy8gdmFsdWUgYmV0d2VlbiAwPD4xIGluZGljYXRpbmcgdGhlIHJlbGF0aXZlIHBvcyBhbG9uZyB0aGUgKGV4cG9zZWQpIGxpbmVcbiAgICBsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZXM6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogdXBkRGF0YVBob3RvbnNcbiAgICB9LFxuICAgIC8vIGFuaW1hdGUgcGhvdG9ucyB0cmF2ZWxsaW5nIGluIHRoZSBsaW5rIGRpcmVjdGlvblxuICAgIGxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlU3BlZWQ6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLjAxLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIC8vIGluIGxpbmsgbGVuZ3RoIHJhdGlvIHBlciBmcmFtZVxuICAgIGxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlT2Zmc2V0OiB7XG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICAvLyBzdGFydGluZyBwb3NpdGlvbiBvZmZzZXQgYWxvbmcgdGhlIGxpbmsncyBsZW5ndGgsIGxpa2UgYSBwcmUtZGVsYXkuIFZhbHVlcyBiZXR3ZWVuIFswLCAxXVxuICAgIGxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlV2lkdGg6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiA0LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlQ29sb3I6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZUNhbnZhc09iamVjdDoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGdsb2JhbFNjYWxlOiB7XG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBkM0FscGhhTWluOiB7XG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBkM0FscGhhRGVjYXk6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLjAyMjgsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShhbHBoYURlY2F5LCBzdGF0ZSkge1xuICAgICAgICBzdGF0ZS5mb3JjZUxheW91dC5hbHBoYURlY2F5KGFscGhhRGVjYXkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZDNBbHBoYVRhcmdldDoge1xuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShhbHBoYVRhcmdldCwgc3RhdGUpIHtcbiAgICAgICAgc3RhdGUuZm9yY2VMYXlvdXQuYWxwaGFUYXJnZXQoYWxwaGFUYXJnZXQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZDNWZWxvY2l0eURlY2F5OiB7XG4gICAgICBcImRlZmF1bHRcIjogMC40LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UodmVsb2NpdHlEZWNheSwgc3RhdGUpIHtcbiAgICAgICAgc3RhdGUuZm9yY2VMYXlvdXQudmVsb2NpdHlEZWNheSh2ZWxvY2l0eURlY2F5KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdhcm11cFRpY2tzOiB7XG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICAvLyBob3cgbWFueSB0aW1lcyB0byB0aWNrIHRoZSBmb3JjZSBlbmdpbmUgYXQgaW5pdCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVuZGVyXG4gICAgY29vbGRvd25UaWNrczoge1xuICAgICAgXCJkZWZhdWx0XCI6IEluZmluaXR5LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGNvb2xkb3duVGltZToge1xuICAgICAgXCJkZWZhdWx0XCI6IDE1MDAwLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIC8vIG1zXG4gICAgb25VcGRhdGU6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHt9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uRmluaXNoVXBkYXRlOiB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7fSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbkVuZ2luZVRpY2s6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHt9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uRW5naW5lU3RvcDoge1xuICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge30sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25OZWVkc1JlZHJhdzoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGlzU2hhZG93OiB7XG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIC8vIEV4cG9zZSBkMyBmb3JjZXMgZm9yIGV4dGVybmFsIG1hbmlwdWxhdGlvblxuICAgIGQzRm9yY2U6IGZ1bmN0aW9uIGQzRm9yY2Uoc3RhdGUsIGZvcmNlTmFtZSwgZm9yY2VGbikge1xuICAgICAgaWYgKGZvcmNlRm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc3RhdGUuZm9yY2VMYXlvdXQuZm9yY2UoZm9yY2VOYW1lKTsgLy8gRm9yY2UgZ2V0dGVyXG4gICAgICB9XG4gICAgICBzdGF0ZS5mb3JjZUxheW91dC5mb3JjZShmb3JjZU5hbWUsIGZvcmNlRm4pOyAvLyBGb3JjZSBzZXR0ZXJcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZDNSZWhlYXRTaW11bGF0aW9uOiBmdW5jdGlvbiBkM1JlaGVhdFNpbXVsYXRpb24oc3RhdGUpIHtcbiAgICAgIHN0YXRlLmZvcmNlTGF5b3V0LmFscGhhKDEpO1xuICAgICAgdGhpcy5yZXNldENvdW50ZG93bigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyByZXNldCBjb29sZG93biBzdGF0ZVxuICAgIHJlc2V0Q291bnRkb3duOiBmdW5jdGlvbiByZXNldENvdW50ZG93bihzdGF0ZSkge1xuICAgICAgc3RhdGUuY250VGlja3MgPSAwO1xuICAgICAgc3RhdGUuc3RhcnRUaWNrVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICBzdGF0ZS5lbmdpbmVSdW5uaW5nID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgaXNFbmdpbmVSdW5uaW5nOiBmdW5jdGlvbiBpc0VuZ2luZVJ1bm5pbmcoc3RhdGUpIHtcbiAgICAgIHJldHVybiAhIXN0YXRlLmVuZ2luZVJ1bm5pbmc7XG4gICAgfSxcbiAgICB0aWNrRnJhbWU6IGZ1bmN0aW9uIHRpY2tGcmFtZShzdGF0ZSkge1xuICAgICAgIXN0YXRlLmlzU2hhZG93ICYmIGxheW91dFRpY2soKTtcbiAgICAgIHBhaW50TGlua3MoKTtcbiAgICAgICFzdGF0ZS5pc1NoYWRvdyAmJiBwYWludEFycm93cygpO1xuICAgICAgIXN0YXRlLmlzU2hhZG93ICYmIHBhaW50UGhvdG9ucygpO1xuICAgICAgcGFpbnROb2RlcygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vXG5cbiAgICAgIGZ1bmN0aW9uIGxheW91dFRpY2soKSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmdpbmVSdW5uaW5nKSB7XG4gICAgICAgICAgaWYgKCsrc3RhdGUuY250VGlja3MgPiBzdGF0ZS5jb29sZG93blRpY2tzIHx8IG5ldyBEYXRlKCkgLSBzdGF0ZS5zdGFydFRpY2tUaW1lID4gc3RhdGUuY29vbGRvd25UaW1lIHx8IHN0YXRlLmQzQWxwaGFNaW4gPiAwICYmIHN0YXRlLmZvcmNlTGF5b3V0LmFscGhhKCkgPCBzdGF0ZS5kM0FscGhhTWluKSB7XG4gICAgICAgICAgICBzdGF0ZS5lbmdpbmVSdW5uaW5nID0gZmFsc2U7IC8vIFN0b3AgdGlja2luZyBncmFwaFxuICAgICAgICAgICAgc3RhdGUub25FbmdpbmVTdG9wKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmZvcmNlTGF5b3V0LnRpY2soKTsgLy8gVGljayBpdFxuICAgICAgICAgICAgc3RhdGUub25FbmdpbmVUaWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwYWludE5vZGVzKCkge1xuICAgICAgICB2YXIgZ2V0VmlzaWJpbGl0eSA9IGFjY2Vzc29yRm4oc3RhdGUubm9kZVZpc2liaWxpdHkpO1xuICAgICAgICB2YXIgZ2V0VmFsID0gYWNjZXNzb3JGbihzdGF0ZS5ub2RlVmFsKTtcbiAgICAgICAgdmFyIGdldENvbG9yID0gYWNjZXNzb3JGbihzdGF0ZS5ub2RlQ29sb3IpO1xuICAgICAgICB2YXIgZ2V0Tm9kZUNhbnZhc09iamVjdE1vZGUgPSBhY2Nlc3NvckZuKHN0YXRlLm5vZGVDYW52YXNPYmplY3RNb2RlKTtcbiAgICAgICAgdmFyIGN0eCA9IHN0YXRlLmN0eDtcblxuICAgICAgICAvLyBEcmF3IHdpZGVyIG5vZGVzIGJ5IDFweCBvbiBzaGFkb3cgY2FudmFzIGZvciBtb3JlIHByZWNpc2UgaG92ZXJpbmcgKGR1ZSB0byBib3VuZGFyeSBhbnRpLWFsaWFzaW5nKVxuICAgICAgICB2YXIgcGFkQW1vdW50ID0gc3RhdGUuaXNTaGFkb3cgLyBzdGF0ZS5nbG9iYWxTY2FsZTtcbiAgICAgICAgdmFyIHZpc2libGVOb2RlcyA9IHN0YXRlLmdyYXBoRGF0YS5ub2Rlcy5maWx0ZXIoZ2V0VmlzaWJpbGl0eSk7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIHZpc2libGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgdmFyIG5vZGVDYW52YXNPYmplY3RNb2RlID0gZ2V0Tm9kZUNhbnZhc09iamVjdE1vZGUobm9kZSk7XG4gICAgICAgICAgaWYgKHN0YXRlLm5vZGVDYW52YXNPYmplY3QgJiYgKG5vZGVDYW52YXNPYmplY3RNb2RlID09PSAnYmVmb3JlJyB8fCBub2RlQ2FudmFzT2JqZWN0TW9kZSA9PT0gJ3JlcGxhY2UnKSkge1xuICAgICAgICAgICAgLy8gQ3VzdG9tIG5vZGUgYmVmb3JlL3JlcGxhY2UgcGFpbnRcbiAgICAgICAgICAgIHN0YXRlLm5vZGVDYW52YXNPYmplY3Qobm9kZSwgY3R4LCBzdGF0ZS5nbG9iYWxTY2FsZSk7XG4gICAgICAgICAgICBpZiAobm9kZUNhbnZhc09iamVjdE1vZGUgPT09ICdyZXBsYWNlJykge1xuICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRHJhdyB3aWRlciBub2RlcyBieSAxcHggb24gc2hhZG93IGNhbnZhcyBmb3IgbW9yZSBwcmVjaXNlIGhvdmVyaW5nIChkdWUgdG8gYm91bmRhcnkgYW50aS1hbGlhc2luZylcbiAgICAgICAgICB2YXIgciA9IE1hdGguc3FydChNYXRoLm1heCgwLCBnZXRWYWwobm9kZSkgfHwgMSkpICogc3RhdGUubm9kZVJlbFNpemUgKyBwYWRBbW91bnQ7XG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5hcmMobm9kZS54LCBub2RlLnksIHIsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdldENvbG9yKG5vZGUpIHx8ICdyZ2JhKDMxLCAxMjAsIDE4MCwgMC45MiknO1xuICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgaWYgKHN0YXRlLm5vZGVDYW52YXNPYmplY3QgJiYgbm9kZUNhbnZhc09iamVjdE1vZGUgPT09ICdhZnRlcicpIHtcbiAgICAgICAgICAgIC8vIEN1c3RvbSBub2RlIGFmdGVyIHBhaW50XG4gICAgICAgICAgICBzdGF0ZS5ub2RlQ2FudmFzT2JqZWN0KG5vZGUsIHN0YXRlLmN0eCwgc3RhdGUuZ2xvYmFsU2NhbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwYWludExpbmtzKCkge1xuICAgICAgICB2YXIgZ2V0VmlzaWJpbGl0eSA9IGFjY2Vzc29yRm4oc3RhdGUubGlua1Zpc2liaWxpdHkpO1xuICAgICAgICB2YXIgZ2V0Q29sb3IgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtDb2xvcik7XG4gICAgICAgIHZhciBnZXRXaWR0aCA9IGFjY2Vzc29yRm4oc3RhdGUubGlua1dpZHRoKTtcbiAgICAgICAgdmFyIGdldExpbmVEYXNoID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rTGluZURhc2gpO1xuICAgICAgICB2YXIgZ2V0Q3VydmF0dXJlID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rQ3VydmF0dXJlKTtcbiAgICAgICAgdmFyIGdldExpbmtDYW52YXNPYmplY3RNb2RlID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rQ2FudmFzT2JqZWN0TW9kZSk7XG4gICAgICAgIHZhciBjdHggPSBzdGF0ZS5jdHg7XG5cbiAgICAgICAgLy8gRHJhdyB3aWRlciBsaW5lcyBieSAycHggb24gc2hhZG93IGNhbnZhcyBmb3IgbW9yZSBwcmVjaXNlIGhvdmVyaW5nIChkdWUgdG8gYm91bmRhcnkgYW50aS1hbGlhc2luZylcbiAgICAgICAgdmFyIHBhZEFtb3VudCA9IHN0YXRlLmlzU2hhZG93ICogMjtcbiAgICAgICAgdmFyIHZpc2libGVMaW5rcyA9IHN0YXRlLmdyYXBoRGF0YS5saW5rcy5maWx0ZXIoZ2V0VmlzaWJpbGl0eSk7XG4gICAgICAgIHZpc2libGVMaW5rcy5mb3JFYWNoKGNhbGNMaW5rQ29udHJvbFBvaW50cyk7IC8vIGNhbGN1bGF0ZSBjdXJ2YXR1cmUgY29udHJvbCBwb2ludHMgZm9yIGFsbCB2aXNpYmxlIGxpbmtzXG5cbiAgICAgICAgdmFyIGJlZm9yZUN1c3RvbUxpbmtzID0gW10sXG4gICAgICAgICAgYWZ0ZXJDdXN0b21MaW5rcyA9IFtdLFxuICAgICAgICAgIGRlZmF1bHRQYWludExpbmtzID0gdmlzaWJsZUxpbmtzO1xuICAgICAgICBpZiAoc3RhdGUubGlua0NhbnZhc09iamVjdCkge1xuICAgICAgICAgIHZhciByZXBsYWNlQ3VzdG9tTGlua3MgPSBbXSxcbiAgICAgICAgICAgIG90aGVyQ3VzdG9tTGlua3MgPSBbXTtcbiAgICAgICAgICB2aXNpYmxlTGlua3MuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICAgIGJlZm9yZTogYmVmb3JlQ3VzdG9tTGlua3MsXG4gICAgICAgICAgICAgIGFmdGVyOiBhZnRlckN1c3RvbUxpbmtzLFxuICAgICAgICAgICAgICByZXBsYWNlOiByZXBsYWNlQ3VzdG9tTGlua3NcbiAgICAgICAgICAgIH1bZ2V0TGlua0NhbnZhc09iamVjdE1vZGUoZCldIHx8IG90aGVyQ3VzdG9tTGlua3MpLnB1c2goZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGVmYXVsdFBhaW50TGlua3MgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGJlZm9yZUN1c3RvbUxpbmtzKSwgYWZ0ZXJDdXN0b21MaW5rcywgb3RoZXJDdXN0b21MaW5rcyk7XG4gICAgICAgICAgYmVmb3JlQ3VzdG9tTGlua3MgPSBiZWZvcmVDdXN0b21MaW5rcy5jb25jYXQocmVwbGFjZUN1c3RvbUxpbmtzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEN1c3RvbSBsaW5rIGJlZm9yZSBwYWludHNcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgYmVmb3JlQ3VzdG9tTGlua3MuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgIHJldHVybiBzdGF0ZS5saW5rQ2FudmFzT2JqZWN0KGxpbmssIGN0eCwgc3RhdGUuZ2xvYmFsU2NhbGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICAvLyBCdW5kbGUgc3Ryb2tlcyBwZXIgdW5pcXVlIGNvbG9yL3dpZHRoL2Rhc2ggZm9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvblxuICAgICAgICB2YXIgbGlua3NQZXJDb2xvciA9IGluZGV4QnkoZGVmYXVsdFBhaW50TGlua3MsIFtnZXRDb2xvciwgZ2V0V2lkdGgsIGdldExpbmVEYXNoXSk7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGxpbmtzUGVyQ29sb3IpLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgICAgIGNvbG9yID0gX3JlZjJbMF0sXG4gICAgICAgICAgICBsaW5rc1BlcldpZHRoID0gX3JlZjJbMV07XG4gICAgICAgICAgdmFyIGxpbmVDb2xvciA9ICFjb2xvciB8fCBjb2xvciA9PT0gJ3VuZGVmaW5lZCcgPyAncmdiYSgwLDAsMCwwLjE1KScgOiBjb2xvcjtcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhsaW5rc1BlcldpZHRoKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICAgICAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDIpLFxuICAgICAgICAgICAgICB3aWR0aCA9IF9yZWY0WzBdLFxuICAgICAgICAgICAgICBsaW5lc1BlckxpbmVEYXNoID0gX3JlZjRbMV07XG4gICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gKHdpZHRoIHx8IDEpIC8gc3RhdGUuZ2xvYmFsU2NhbGUgKyBwYWRBbW91bnQ7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhsaW5lc1BlckxpbmVEYXNoKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmNSkge1xuICAgICAgICAgICAgICB2YXIgX3JlZjYgPSBfc2xpY2VkVG9BcnJheShfcmVmNSwgMik7XG4gICAgICAgICAgICAgICAgX3JlZjZbMF07XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtzID0gX3JlZjZbMV07XG4gICAgICAgICAgICAgIHZhciBsaW5lRGFzaFNlZ21lbnRzID0gZ2V0TGluZURhc2gobGlua3NbMF0pO1xuICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgIGxpbmtzLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBsaW5rLnNvdXJjZTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gbGluay50YXJnZXQ7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGFydCB8fCAhZW5kIHx8ICFzdGFydC5oYXNPd25Qcm9wZXJ0eSgneCcpIHx8ICFlbmQuaGFzT3duUHJvcGVydHkoJ3gnKSkgcmV0dXJuOyAvLyBza2lwIGludmFsaWQgbGlua1xuXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhzdGFydC54LCBzdGFydC55KTtcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbFBvaW50cyA9IGxpbmsuX19jb250cm9sUG9pbnRzO1xuICAgICAgICAgICAgICAgIGlmICghY29udHJvbFBvaW50cykge1xuICAgICAgICAgICAgICAgICAgLy8gU3RyYWlnaHQgbGluZVxuICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhlbmQueCwgZW5kLnkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBVc2UgcXVhZHJhdGljIGN1cnZlcyBmb3IgcmVndWxhciBsaW5lcyBhbmQgYmV6aWVyIGZvciBsb29wc1xuICAgICAgICAgICAgICAgICAgY3R4W2NvbnRyb2xQb2ludHMubGVuZ3RoID09PSAyID8gJ3F1YWRyYXRpY0N1cnZlVG8nIDogJ2JlemllckN1cnZlVG8nXS5hcHBseShjdHgsIF90b0NvbnN1bWFibGVBcnJheShjb250cm9sUG9pbnRzKS5jb25jYXQoW2VuZC54LCBlbmQueV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsaW5lQ29sb3I7XG4gICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChsaW5lRGFzaFNlZ21lbnRzIHx8IFtdKTtcbiAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAgIC8vIEN1c3RvbSBsaW5rIGFmdGVyIHBhaW50c1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBhZnRlckN1c3RvbUxpbmtzLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUubGlua0NhbnZhc09iamVjdChsaW5rLCBjdHgsIHN0YXRlLmdsb2JhbFNjYWxlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgLy9cblxuICAgICAgICBmdW5jdGlvbiBjYWxjTGlua0NvbnRyb2xQb2ludHMobGluaykge1xuICAgICAgICAgIHZhciBjdXJ2YXR1cmUgPSBnZXRDdXJ2YXR1cmUobGluayk7XG4gICAgICAgICAgaWYgKCFjdXJ2YXR1cmUpIHtcbiAgICAgICAgICAgIC8vIHN0cmFpZ2h0IGxpbmVcbiAgICAgICAgICAgIGxpbmsuX19jb250cm9sUG9pbnRzID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gbGluay5zb3VyY2U7XG4gICAgICAgICAgdmFyIGVuZCA9IGxpbmsudGFyZ2V0O1xuICAgICAgICAgIGlmICghc3RhcnQgfHwgIWVuZCB8fCAhc3RhcnQuaGFzT3duUHJvcGVydHkoJ3gnKSB8fCAhZW5kLmhhc093blByb3BlcnR5KCd4JykpIHJldHVybjsgLy8gc2tpcCBpbnZhbGlkIGxpbmtcblxuICAgICAgICAgIHZhciBsID0gTWF0aC5zcXJ0KE1hdGgucG93KGVuZC54IC0gc3RhcnQueCwgMikgKyBNYXRoLnBvdyhlbmQueSAtIHN0YXJ0LnksIDIpKTsgLy8gbGluZSBsZW5ndGhcblxuICAgICAgICAgIGlmIChsID4gMCkge1xuICAgICAgICAgICAgdmFyIGEgPSBNYXRoLmF0YW4yKGVuZC55IC0gc3RhcnQueSwgZW5kLnggLSBzdGFydC54KTsgLy8gbGluZSBhbmdsZVxuICAgICAgICAgICAgdmFyIGQgPSBsICogY3VydmF0dXJlOyAvLyBjb250cm9sIHBvaW50IGRpc3RhbmNlXG5cbiAgICAgICAgICAgIHZhciBjcCA9IHtcbiAgICAgICAgICAgICAgLy8gY29udHJvbCBwb2ludFxuICAgICAgICAgICAgICB4OiAoc3RhcnQueCArIGVuZC54KSAvIDIgKyBkICogTWF0aC5jb3MoYSAtIE1hdGguUEkgLyAyKSxcbiAgICAgICAgICAgICAgeTogKHN0YXJ0LnkgKyBlbmQueSkgLyAyICsgZCAqIE1hdGguc2luKGEgLSBNYXRoLlBJIC8gMilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsaW5rLl9fY29udHJvbFBvaW50cyA9IFtjcC54LCBjcC55XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2FtZSBwb2ludCwgZHJhdyBhIGxvb3BcbiAgICAgICAgICAgIHZhciBfZCA9IGN1cnZhdHVyZSAqIDcwO1xuICAgICAgICAgICAgbGluay5fX2NvbnRyb2xQb2ludHMgPSBbZW5kLngsIGVuZC55IC0gX2QsIGVuZC54ICsgX2QsIGVuZC55XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhaW50QXJyb3dzKCkge1xuICAgICAgICB2YXIgQVJST1dfV0hfUkFUSU8gPSAxLjY7XG4gICAgICAgIHZhciBBUlJPV19WTEVOX1JBVElPID0gMC4yO1xuICAgICAgICB2YXIgZ2V0TGVuZ3RoID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rRGlyZWN0aW9uYWxBcnJvd0xlbmd0aCk7XG4gICAgICAgIHZhciBnZXRSZWxQb3MgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtEaXJlY3Rpb25hbEFycm93UmVsUG9zKTtcbiAgICAgICAgdmFyIGdldFZpc2liaWxpdHkgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtWaXNpYmlsaXR5KTtcbiAgICAgICAgdmFyIGdldENvbG9yID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rRGlyZWN0aW9uYWxBcnJvd0NvbG9yIHx8IHN0YXRlLmxpbmtDb2xvcik7XG4gICAgICAgIHZhciBnZXROb2RlVmFsID0gYWNjZXNzb3JGbihzdGF0ZS5ub2RlVmFsKTtcbiAgICAgICAgdmFyIGN0eCA9IHN0YXRlLmN0eDtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgc3RhdGUuZ3JhcGhEYXRhLmxpbmtzLmZpbHRlcihnZXRWaXNpYmlsaXR5KS5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgICAgdmFyIGFycm93TGVuZ3RoID0gZ2V0TGVuZ3RoKGxpbmspO1xuICAgICAgICAgIGlmICghYXJyb3dMZW5ndGggfHwgYXJyb3dMZW5ndGggPCAwKSByZXR1cm47XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gbGluay5zb3VyY2U7XG4gICAgICAgICAgdmFyIGVuZCA9IGxpbmsudGFyZ2V0O1xuICAgICAgICAgIGlmICghc3RhcnQgfHwgIWVuZCB8fCAhc3RhcnQuaGFzT3duUHJvcGVydHkoJ3gnKSB8fCAhZW5kLmhhc093blByb3BlcnR5KCd4JykpIHJldHVybjsgLy8gc2tpcCBpbnZhbGlkIGxpbmtcblxuICAgICAgICAgIHZhciBzdGFydFIgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgZ2V0Tm9kZVZhbChzdGFydCkgfHwgMSkpICogc3RhdGUubm9kZVJlbFNpemU7XG4gICAgICAgICAgdmFyIGVuZFIgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgZ2V0Tm9kZVZhbChlbmQpIHx8IDEpKSAqIHN0YXRlLm5vZGVSZWxTaXplO1xuICAgICAgICAgIHZhciBhcnJvd1JlbFBvcyA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGdldFJlbFBvcyhsaW5rKSkpO1xuICAgICAgICAgIHZhciBhcnJvd0NvbG9yID0gZ2V0Q29sb3IobGluaykgfHwgJ3JnYmEoMCwwLDAsMC4yOCknO1xuICAgICAgICAgIHZhciBhcnJvd0hhbGZXaWR0aCA9IGFycm93TGVuZ3RoIC8gQVJST1dfV0hfUkFUSU8gLyAyO1xuXG4gICAgICAgICAgLy8gQ29uc3RydWN0IGJlemllciBmb3IgY3VydmVkIGxpbmVzXG4gICAgICAgICAgdmFyIGJ6TGluZSA9IGxpbmsuX19jb250cm9sUG9pbnRzICYmIF9jb25zdHJ1Y3QoQmV6aWVyLCBbc3RhcnQueCwgc3RhcnQueV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShsaW5rLl9fY29udHJvbFBvaW50cyksIFtlbmQueCwgZW5kLnldKSk7XG4gICAgICAgICAgdmFyIGdldENvb3Jkc0Fsb25nTGluZSA9IGJ6TGluZSA/IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gYnpMaW5lLmdldCh0KTtcbiAgICAgICAgICB9IC8vIGdldCBwb3NpdGlvbiBhbG9uZyBiZXppZXIgbGluZVxuICAgICAgICAgIDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC8vIHN0cmFpZ2h0IGxpbmU6IGludGVycG9sYXRlIGxpbmVhcmx5XG4gICAgICAgICAgICAgIHg6IHN0YXJ0LnggKyAoZW5kLnggLSBzdGFydC54KSAqIHQgfHwgMCxcbiAgICAgICAgICAgICAgeTogc3RhcnQueSArIChlbmQueSAtIHN0YXJ0LnkpICogdCB8fCAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGxpbmVMZW4gPSBiekxpbmUgPyBiekxpbmUubGVuZ3RoKCkgOiBNYXRoLnNxcnQoTWF0aC5wb3coZW5kLnggLSBzdGFydC54LCAyKSArIE1hdGgucG93KGVuZC55IC0gc3RhcnQueSwgMikpO1xuICAgICAgICAgIHZhciBwb3NBbG9uZ0xpbmUgPSBzdGFydFIgKyBhcnJvd0xlbmd0aCArIChsaW5lTGVuIC0gc3RhcnRSIC0gZW5kUiAtIGFycm93TGVuZ3RoKSAqIGFycm93UmVsUG9zO1xuICAgICAgICAgIHZhciBhcnJvd0hlYWQgPSBnZXRDb29yZHNBbG9uZ0xpbmUocG9zQWxvbmdMaW5lIC8gbGluZUxlbik7XG4gICAgICAgICAgdmFyIGFycm93VGFpbCA9IGdldENvb3Jkc0Fsb25nTGluZSgocG9zQWxvbmdMaW5lIC0gYXJyb3dMZW5ndGgpIC8gbGluZUxlbik7XG4gICAgICAgICAgdmFyIGFycm93VGFpbFZlcnRleCA9IGdldENvb3Jkc0Fsb25nTGluZSgocG9zQWxvbmdMaW5lIC0gYXJyb3dMZW5ndGggKiAoMSAtIEFSUk9XX1ZMRU5fUkFUSU8pKSAvIGxpbmVMZW4pO1xuICAgICAgICAgIHZhciBhcnJvd1RhaWxBbmdsZSA9IE1hdGguYXRhbjIoYXJyb3dIZWFkLnkgLSBhcnJvd1RhaWwueSwgYXJyb3dIZWFkLnggLSBhcnJvd1RhaWwueCkgLSBNYXRoLlBJIC8gMjtcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4Lm1vdmVUbyhhcnJvd0hlYWQueCwgYXJyb3dIZWFkLnkpO1xuICAgICAgICAgIGN0eC5saW5lVG8oYXJyb3dUYWlsLnggKyBhcnJvd0hhbGZXaWR0aCAqIE1hdGguY29zKGFycm93VGFpbEFuZ2xlKSwgYXJyb3dUYWlsLnkgKyBhcnJvd0hhbGZXaWR0aCAqIE1hdGguc2luKGFycm93VGFpbEFuZ2xlKSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyhhcnJvd1RhaWxWZXJ0ZXgueCwgYXJyb3dUYWlsVmVydGV4LnkpO1xuICAgICAgICAgIGN0eC5saW5lVG8oYXJyb3dUYWlsLnggLSBhcnJvd0hhbGZXaWR0aCAqIE1hdGguY29zKGFycm93VGFpbEFuZ2xlKSwgYXJyb3dUYWlsLnkgLSBhcnJvd0hhbGZXaWR0aCAqIE1hdGguc2luKGFycm93VGFpbEFuZ2xlKSk7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGFycm93Q29sb3I7XG4gICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwYWludFBob3RvbnMoKSB7XG4gICAgICAgIHZhciBnZXROdW1QaG90b25zID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rRGlyZWN0aW9uYWxQYXJ0aWNsZXMpO1xuICAgICAgICB2YXIgZ2V0U3BlZWQgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlU3BlZWQpO1xuICAgICAgICB2YXIgZ2V0T2Zmc2V0ID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rRGlyZWN0aW9uYWxQYXJ0aWNsZU9mZnNldCk7XG4gICAgICAgIHZhciBnZXREaWFtZXRlciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0RpcmVjdGlvbmFsUGFydGljbGVXaWR0aCk7XG4gICAgICAgIHZhciBnZXRWaXNpYmlsaXR5ID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rVmlzaWJpbGl0eSk7XG4gICAgICAgIHZhciBnZXRDb2xvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0RpcmVjdGlvbmFsUGFydGljbGVDb2xvciB8fCBzdGF0ZS5saW5rQ29sb3IpO1xuICAgICAgICB2YXIgY3R4ID0gc3RhdGUuY3R4O1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBzdGF0ZS5ncmFwaERhdGEubGlua3MuZmlsdGVyKGdldFZpc2liaWxpdHkpLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICB2YXIgbnVtQ3ljbGVQaG90b25zID0gZ2V0TnVtUGhvdG9ucyhsaW5rKTtcbiAgICAgICAgICBpZiAoIWxpbmsuaGFzT3duUHJvcGVydHkoJ19fcGhvdG9ucycpIHx8ICFsaW5rLl9fcGhvdG9ucy5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBsaW5rLnNvdXJjZTtcbiAgICAgICAgICB2YXIgZW5kID0gbGluay50YXJnZXQ7XG4gICAgICAgICAgaWYgKCFzdGFydCB8fCAhZW5kIHx8ICFzdGFydC5oYXNPd25Qcm9wZXJ0eSgneCcpIHx8ICFlbmQuaGFzT3duUHJvcGVydHkoJ3gnKSkgcmV0dXJuOyAvLyBza2lwIGludmFsaWQgbGlua1xuXG4gICAgICAgICAgdmFyIHBhcnRpY2xlU3BlZWQgPSBnZXRTcGVlZChsaW5rKTtcbiAgICAgICAgICB2YXIgcGFydGljbGVPZmZzZXQgPSBNYXRoLmFicyhnZXRPZmZzZXQobGluaykpO1xuICAgICAgICAgIHZhciBwaG90b25zID0gbGluay5fX3Bob3RvbnMgfHwgW107XG4gICAgICAgICAgdmFyIHBob3RvblIgPSBNYXRoLm1heCgwLCBnZXREaWFtZXRlcihsaW5rKSAvIDIpIC8gTWF0aC5zcXJ0KHN0YXRlLmdsb2JhbFNjYWxlKTtcbiAgICAgICAgICB2YXIgcGhvdG9uQ29sb3IgPSBnZXRDb2xvcihsaW5rKSB8fCAncmdiYSgwLDAsMCwwLjI4KSc7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHBob3RvbkNvbG9yO1xuXG4gICAgICAgICAgLy8gQ29uc3RydWN0IGJlemllciBmb3IgY3VydmVkIGxpbmVzXG4gICAgICAgICAgdmFyIGJ6TGluZSA9IGxpbmsuX19jb250cm9sUG9pbnRzID8gX2NvbnN0cnVjdChCZXppZXIsIFtzdGFydC54LCBzdGFydC55XS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGxpbmsuX19jb250cm9sUG9pbnRzKSwgW2VuZC54LCBlbmQueV0pKSA6IG51bGw7XG4gICAgICAgICAgdmFyIGN5Y2xlUGhvdG9uSWR4ID0gMDtcbiAgICAgICAgICB2YXIgbmVlZHNDbGVhbnVwID0gZmFsc2U7IC8vIHdoZXRoZXIgc29tZSBwaG90b25zIG5lZWQgdG8gYmUgcmVtb3ZlZCBmcm9tIGxpc3RcbiAgICAgICAgICBwaG90b25zLmZvckVhY2goZnVuY3Rpb24gKHBob3Rvbikge1xuICAgICAgICAgICAgdmFyIHNpbmdsZUhvcCA9ICEhcGhvdG9uLl9fc2luZ2xlSG9wO1xuICAgICAgICAgICAgaWYgKCFwaG90b24uaGFzT3duUHJvcGVydHkoJ19fcHJvZ3Jlc3NSYXRpbycpKSB7XG4gICAgICAgICAgICAgIHBob3Rvbi5fX3Byb2dyZXNzUmF0aW8gPSBzaW5nbGVIb3AgPyAwIDogKGN5Y2xlUGhvdG9uSWR4ICsgcGFydGljbGVPZmZzZXQpIC8gbnVtQ3ljbGVQaG90b25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgIXNpbmdsZUhvcCAmJiBjeWNsZVBob3RvbklkeCsrOyAvLyBpbmNyZWFzZSByZWd1bGFyIHBob3RvbiBpbmRleFxuXG4gICAgICAgICAgICBwaG90b24uX19wcm9ncmVzc1JhdGlvICs9IHBhcnRpY2xlU3BlZWQ7XG4gICAgICAgICAgICBpZiAocGhvdG9uLl9fcHJvZ3Jlc3NSYXRpbyA+PSAxKSB7XG4gICAgICAgICAgICAgIGlmICghc2luZ2xlSG9wKSB7XG4gICAgICAgICAgICAgICAgcGhvdG9uLl9fcHJvZ3Jlc3NSYXRpbyA9IHBob3Rvbi5fX3Byb2dyZXNzUmF0aW8gJSAxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5lZWRzQ2xlYW51cCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGhvdG9uUG9zUmF0aW8gPSBwaG90b24uX19wcm9ncmVzc1JhdGlvO1xuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IGJ6TGluZSA/IGJ6TGluZS5nZXQocGhvdG9uUG9zUmF0aW8pIC8vIGdldCBwb3NpdGlvbiBhbG9uZyBiZXppZXIgbGluZVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgIC8vIHN0cmFpZ2h0IGxpbmU6IGludGVycG9sYXRlIGxpbmVhcmx5XG4gICAgICAgICAgICAgIHg6IHN0YXJ0LnggKyAoZW5kLnggLSBzdGFydC54KSAqIHBob3RvblBvc1JhdGlvIHx8IDAsXG4gICAgICAgICAgICAgIHk6IHN0YXJ0LnkgKyAoZW5kLnkgLSBzdGFydC55KSAqIHBob3RvblBvc1JhdGlvIHx8IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoc3RhdGUubGlua0RpcmVjdGlvbmFsUGFydGljbGVDYW52YXNPYmplY3QpIHtcbiAgICAgICAgICAgICAgc3RhdGUubGlua0RpcmVjdGlvbmFsUGFydGljbGVDYW52YXNPYmplY3QoY29vcmRzLngsIGNvb3Jkcy55LCBsaW5rLCBjdHgsIHN0YXRlLmdsb2JhbFNjYWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgY3R4LmFyYyhjb29yZHMueCwgY29vcmRzLnksIHBob3RvblIsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKG5lZWRzQ2xlYW51cCkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGV4cGlyZWQgc2luZ2xlIGhvcCBwaG90b25zXG4gICAgICAgICAgICBsaW5rLl9fcGhvdG9ucyA9IGxpbmsuX19waG90b25zLmZpbHRlcihmdW5jdGlvbiAocGhvdG9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhcGhvdG9uLl9fc2luZ2xlSG9wIHx8IHBob3Rvbi5fX3Byb2dyZXNzUmF0aW8gPD0gMTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbWl0UGFydGljbGU6IGZ1bmN0aW9uIGVtaXRQYXJ0aWNsZShzdGF0ZSwgbGluaykge1xuICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgIWxpbmsuX19waG90b25zICYmIChsaW5rLl9fcGhvdG9ucyA9IFtdKTtcbiAgICAgICAgbGluay5fX3Bob3RvbnMucHVzaCh7XG4gICAgICAgICAgX19zaW5nbGVIb3A6IHRydWVcbiAgICAgICAgfSk7IC8vIGFkZCBhIHNpbmdsZSBob3AgcGFydGljbGVcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSxcbiAgc3RhdGVJbml0OiBmdW5jdGlvbiBzdGF0ZUluaXQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcmNlTGF5b3V0OiBmb3JjZVNpbXVsYXRpb24oKS5mb3JjZSgnbGluaycsIGZvcmNlTGluaygpKS5mb3JjZSgnY2hhcmdlJywgZm9yY2VNYW55Qm9keSgpKS5mb3JjZSgnY2VudGVyJywgZm9yY2VDZW50ZXIoKSkuZm9yY2UoJ2RhZ1JhZGlhbCcsIG51bGwpLnN0b3AoKSxcbiAgICAgIGVuZ2luZVJ1bm5pbmc6IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgaW5pdDogZnVuY3Rpb24gaW5pdChjYW52YXNDdHgsIHN0YXRlKSB7XG4gICAgLy8gTWFpbiBjYW52YXMgb2JqZWN0IHRvIG1hbmlwdWxhdGVcbiAgICBzdGF0ZS5jdHggPSBjYW52YXNDdHg7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHN0YXRlLCBjaGFuZ2VkUHJvcHMpIHtcbiAgICBzdGF0ZS5lbmdpbmVSdW5uaW5nID0gZmFsc2U7IC8vIFBhdXNlIHNpbXVsYXRpb25cbiAgICBzdGF0ZS5vblVwZGF0ZSgpO1xuICAgIGlmIChzdGF0ZS5ub2RlQXV0b0NvbG9yQnkgIT09IG51bGwpIHtcbiAgICAgIC8vIEF1dG8gYWRkIGNvbG9yIHRvIHVuY29sb3JlZCBub2Rlc1xuICAgICAgYXV0b0NvbG9yT2JqZWN0cyhzdGF0ZS5ncmFwaERhdGEubm9kZXMsIGFjY2Vzc29yRm4oc3RhdGUubm9kZUF1dG9Db2xvckJ5KSwgc3RhdGUubm9kZUNvbG9yKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmxpbmtBdXRvQ29sb3JCeSAhPT0gbnVsbCkge1xuICAgICAgLy8gQXV0byBhZGQgY29sb3IgdG8gdW5jb2xvcmVkIGxpbmtzXG4gICAgICBhdXRvQ29sb3JPYmplY3RzKHN0YXRlLmdyYXBoRGF0YS5saW5rcywgYWNjZXNzb3JGbihzdGF0ZS5saW5rQXV0b0NvbG9yQnkpLCBzdGF0ZS5saW5rQ29sb3IpO1xuICAgIH1cblxuICAgIC8vIHBhcnNlIGxpbmtzXG4gICAgc3RhdGUuZ3JhcGhEYXRhLmxpbmtzLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgIGxpbmsuc291cmNlID0gbGlua1tzdGF0ZS5saW5rU291cmNlXTtcbiAgICAgIGxpbmsudGFyZ2V0ID0gbGlua1tzdGF0ZS5saW5rVGFyZ2V0XTtcbiAgICB9KTtcblxuICAgIC8vIEZlZWQgZGF0YSB0byBmb3JjZS1kaXJlY3RlZCBsYXlvdXRcbiAgICBzdGF0ZS5mb3JjZUxheW91dC5zdG9wKCkuYWxwaGEoMSkgLy8gcmUtaGVhdCB0aGUgc2ltdWxhdGlvblxuICAgIC5ub2RlcyhzdGF0ZS5ncmFwaERhdGEubm9kZXMpO1xuXG4gICAgLy8gYWRkIGxpbmtzIChpZiBsaW5rIGZvcmNlIGlzIHN0aWxsIGFjdGl2ZSlcbiAgICB2YXIgbGlua0ZvcmNlID0gc3RhdGUuZm9yY2VMYXlvdXQuZm9yY2UoJ2xpbmsnKTtcbiAgICBpZiAobGlua0ZvcmNlKSB7XG4gICAgICBsaW5rRm9yY2UuaWQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGRbc3RhdGUubm9kZUlkXTtcbiAgICAgIH0pLmxpbmtzKHN0YXRlLmdyYXBoRGF0YS5saW5rcyk7XG4gICAgfVxuXG4gICAgLy8gc2V0dXAgZGFnIGZvcmNlIGNvbnN0cmFpbnRzXG4gICAgdmFyIG5vZGVEZXB0aHMgPSBzdGF0ZS5kYWdNb2RlICYmIGdldERhZ0RlcHRocyhzdGF0ZS5ncmFwaERhdGEsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZVtzdGF0ZS5ub2RlSWRdO1xuICAgIH0sIHtcbiAgICAgIG5vZGVGaWx0ZXI6IHN0YXRlLmRhZ05vZGVGaWx0ZXIsXG4gICAgICBvbkxvb3BFcnJvcjogc3RhdGUub25EYWdFcnJvciB8fCB1bmRlZmluZWRcbiAgICB9KTtcbiAgICB2YXIgbWF4RGVwdGggPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoT2JqZWN0LnZhbHVlcyhub2RlRGVwdGhzIHx8IFtdKSkpO1xuICAgIHZhciBkYWdMZXZlbERpc3RhbmNlID0gc3RhdGUuZGFnTGV2ZWxEaXN0YW5jZSB8fCBzdGF0ZS5ncmFwaERhdGEubm9kZXMubGVuZ3RoIC8gKG1heERlcHRoIHx8IDEpICogREFHX0xFVkVMX05PREVfUkFUSU8gKiAoWydyYWRpYWxpbicsICdyYWRpYWxvdXQnXS5pbmRleE9mKHN0YXRlLmRhZ01vZGUpICE9PSAtMSA/IDAuNyA6IDEpO1xuXG4gICAgLy8gUmVzZXQgcmVsZXZhbnQgZngvZnkgd2hlbiBzd2FwcGluZyBkYWcgbW9kZXNcbiAgICBpZiAoWydscicsICdybCcsICd0ZCcsICdidSddLmluY2x1ZGVzKGNoYW5nZWRQcm9wcy5kYWdNb2RlKSkge1xuICAgICAgdmFyIHJlc2V0UHJvcCA9IFsnbHInLCAncmwnXS5pbmNsdWRlcyhjaGFuZ2VkUHJvcHMuZGFnTW9kZSkgPyAnZngnIDogJ2Z5JztcbiAgICAgIHN0YXRlLmdyYXBoRGF0YS5ub2Rlcy5maWx0ZXIoc3RhdGUuZGFnTm9kZUZpbHRlcikuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gZGVsZXRlIG5vZGVbcmVzZXRQcm9wXTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEZpeCBub2RlcyB0byB4LHkgZm9yIGRhZyBtb2RlXG4gICAgaWYgKFsnbHInLCAncmwnLCAndGQnLCAnYnUnXS5pbmNsdWRlcyhzdGF0ZS5kYWdNb2RlKSkge1xuICAgICAgdmFyIGludmVydCA9IFsncmwnLCAnYnUnXS5pbmNsdWRlcyhzdGF0ZS5kYWdNb2RlKTtcbiAgICAgIHZhciBmaXhGbiA9IGZ1bmN0aW9uIGZpeEZuKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIChub2RlRGVwdGhzW25vZGVbc3RhdGUubm9kZUlkXV0gLSBtYXhEZXB0aCAvIDIpICogZGFnTGV2ZWxEaXN0YW5jZSAqIChpbnZlcnQgPyAtMSA6IDEpO1xuICAgICAgfTtcbiAgICAgIHZhciBfcmVzZXRQcm9wID0gWydscicsICdybCddLmluY2x1ZGVzKHN0YXRlLmRhZ01vZGUpID8gJ2Z4JyA6ICdmeSc7XG4gICAgICBzdGF0ZS5ncmFwaERhdGEubm9kZXMuZmlsdGVyKHN0YXRlLmRhZ05vZGVGaWx0ZXIpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVbX3Jlc2V0UHJvcF0gPSBmaXhGbihub2RlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFVzZSByYWRpYWwgZm9yY2UgZm9yIHJhZGlhbCBkYWdzXG4gICAgc3RhdGUuZm9yY2VMYXlvdXQuZm9yY2UoJ2RhZ1JhZGlhbCcsIFsncmFkaWFsaW4nLCAncmFkaWFsb3V0J10uaW5kZXhPZihzdGF0ZS5kYWdNb2RlKSAhPT0gLTEgPyBmb3JjZVJhZGlhbChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIG5vZGVEZXB0aCA9IG5vZGVEZXB0aHNbbm9kZVtzdGF0ZS5ub2RlSWRdXSB8fCAtMTtcbiAgICAgIHJldHVybiAoc3RhdGUuZGFnTW9kZSA9PT0gJ3JhZGlhbGluJyA/IG1heERlcHRoIC0gbm9kZURlcHRoIDogbm9kZURlcHRoKSAqIGRhZ0xldmVsRGlzdGFuY2U7XG4gICAgfSkuc3RyZW5ndGgoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5kYWdOb2RlRmlsdGVyKG5vZGUpID8gMSA6IDA7XG4gICAgfSkgOiBudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLndhcm11cFRpY2tzICYmICEoc3RhdGUuZDNBbHBoYU1pbiA+IDAgJiYgc3RhdGUuZm9yY2VMYXlvdXQuYWxwaGEoKSA8IHN0YXRlLmQzQWxwaGFNaW4pOyBpKyspIHtcbiAgICAgIHN0YXRlLmZvcmNlTGF5b3V0LnRpY2soKTtcbiAgICB9IC8vIEluaXRpYWwgdGlja3MgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlbmRlclxuXG4gICAgdGhpcy5yZXNldENvdW50ZG93bigpO1xuICAgIHN0YXRlLm9uRmluaXNoVXBkYXRlKCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBsaW5rS2Fwc3VsZSAoa2Fwc3VsZVByb3BOYW1lcywga2Fwc3VsZVR5cGUpIHtcbiAgdmFyIHByb3BOYW1lcyA9IGthcHN1bGVQcm9wTmFtZXMgaW5zdGFuY2VvZiBBcnJheSA/IGthcHN1bGVQcm9wTmFtZXMgOiBba2Fwc3VsZVByb3BOYW1lc107XG4gIHZhciBkdW1teUsgPSBuZXcga2Fwc3VsZVR5cGUoKTsgLy8gVG8gZXh0cmFjdCBkZWZhdWx0c1xuICBkdW1teUsuX2Rlc3RydWN0b3IgJiYgZHVtbXlLLl9kZXN0cnVjdG9yKCk7XG4gIHJldHVybiB7XG4gICAgbGlua1Byb3A6IGZ1bmN0aW9uIGxpbmtQcm9wKHByb3ApIHtcbiAgICAgIC8vIGxpbmsgcHJvcGVydHkgY29uZmlnXG4gICAgICByZXR1cm4ge1xuICAgICAgICBcImRlZmF1bHRcIjogZHVtbXlLW3Byb3BdKCksXG4gICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSh2LCBzdGF0ZSkge1xuICAgICAgICAgIHByb3BOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlW3Byb3BOYW1lXVtwcm9wXSh2KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICAgIH07XG4gICAgfSxcbiAgICBsaW5rTWV0aG9kOiBmdW5jdGlvbiBsaW5rTWV0aG9kKG1ldGhvZCkge1xuICAgICAgLy8gbGluayBtZXRob2QgcGFzcy10aHJvdWdoXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmV0dXJuVmFscyA9IFtdO1xuICAgICAgICBwcm9wTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICB2YXIga2Fwc3VsZUluc3RhbmNlID0gc3RhdGVbcHJvcE5hbWVdO1xuICAgICAgICAgIHZhciByZXR1cm5WYWwgPSBrYXBzdWxlSW5zdGFuY2VbbWV0aG9kXS5hcHBseShrYXBzdWxlSW5zdGFuY2UsIGFyZ3MpO1xuICAgICAgICAgIGlmIChyZXR1cm5WYWwgIT09IGthcHN1bGVJbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuVmFscy5wdXNoKHJldHVyblZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHMubGVuZ3RoID8gcmV0dXJuVmFsc1swXSA6IHRoaXM7IC8vIGNoYWluIGJhc2VkIG9uIHRoZSBwYXJlbnQgb2JqZWN0LCBub3QgdGhlIGlubmVyIGthcHN1bGVcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG52YXIgSE9WRVJfQ0FOVkFTX1RIUk9UVExFX0RFTEFZID0gODAwOyAvLyBtcyB0byB0aHJvdHRsZSBzaGFkb3cgY2FudmFzIHVwZGF0ZXMgZm9yIHBlcmYgaW1wcm92ZW1lbnRcbnZhciBaT09NMk5PREVTX0ZBQ1RPUiA9IDQ7XG52YXIgRFJBR19DTElDS19UT0xFUkFOQ0VfUFggPSA1OyAvLyBIb3cgbWFueSBweCBjYW4gYSBub2RlIGJlIGFjY2lkZW50YWxseSBkcmFnZ2VkIGJlZm9yZSBkaXNhYmxpbmcgdGhlIGNsaWNrXG5cbi8vIEV4cG9zZSBjb25maWcgZnJvbSBmb3JjZUdyYXBoXG52YXIgYmluZEZHID0gbGlua0thcHN1bGUoJ2ZvcmNlR3JhcGgnLCBDYW52YXNGb3JjZUdyYXBoKTtcbnZhciBiaW5kQm90aCA9IGxpbmtLYXBzdWxlKFsnZm9yY2VHcmFwaCcsICdzaGFkb3dHcmFwaCddLCBDYW52YXNGb3JjZUdyYXBoKTtcbnZhciBsaW5rZWRQcm9wcyA9IE9iamVjdC5hc3NpZ24uYXBwbHkoT2JqZWN0LCBfdG9Db25zdW1hYmxlQXJyYXkoWydub2RlQ29sb3InLCAnbm9kZUF1dG9Db2xvckJ5JywgJ25vZGVDYW52YXNPYmplY3QnLCAnbm9kZUNhbnZhc09iamVjdE1vZGUnLCAnbGlua0NvbG9yJywgJ2xpbmtBdXRvQ29sb3JCeScsICdsaW5rTGluZURhc2gnLCAnbGlua1dpZHRoJywgJ2xpbmtDYW52YXNPYmplY3QnLCAnbGlua0NhbnZhc09iamVjdE1vZGUnLCAnbGlua0RpcmVjdGlvbmFsQXJyb3dMZW5ndGgnLCAnbGlua0RpcmVjdGlvbmFsQXJyb3dDb2xvcicsICdsaW5rRGlyZWN0aW9uYWxBcnJvd1JlbFBvcycsICdsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZXMnLCAnbGlua0RpcmVjdGlvbmFsUGFydGljbGVTcGVlZCcsICdsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZU9mZnNldCcsICdsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVdpZHRoJywgJ2xpbmtEaXJlY3Rpb25hbFBhcnRpY2xlQ29sb3InLCAnbGlua0RpcmVjdGlvbmFsUGFydGljbGVDYW52YXNPYmplY3QnLCAnZGFnTW9kZScsICdkYWdMZXZlbERpc3RhbmNlJywgJ2RhZ05vZGVGaWx0ZXInLCAnb25EYWdFcnJvcicsICdkM0FscGhhTWluJywgJ2QzQWxwaGFEZWNheScsICdkM1ZlbG9jaXR5RGVjYXknLCAnd2FybXVwVGlja3MnLCAnY29vbGRvd25UaWNrcycsICdjb29sZG93blRpbWUnLCAnb25FbmdpbmVUaWNrJywgJ29uRW5naW5lU3RvcCddLm1hcChmdW5jdGlvbiAocCkge1xuICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHt9LCBwLCBiaW5kRkcubGlua1Byb3AocCkpO1xufSkpLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoWydub2RlUmVsU2l6ZScsICdub2RlSWQnLCAnbm9kZVZhbCcsICdub2RlVmlzaWJpbGl0eScsICdsaW5rU291cmNlJywgJ2xpbmtUYXJnZXQnLCAnbGlua1Zpc2liaWxpdHknLCAnbGlua0N1cnZhdHVyZSddLm1hcChmdW5jdGlvbiAocCkge1xuICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHt9LCBwLCBiaW5kQm90aC5saW5rUHJvcChwKSk7XG59KSkpKTtcbnZhciBsaW5rZWRNZXRob2RzID0gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIF90b0NvbnN1bWFibGVBcnJheShbJ2QzRm9yY2UnLCAnZDNSZWhlYXRTaW11bGF0aW9uJywgJ2VtaXRQYXJ0aWNsZSddLm1hcChmdW5jdGlvbiAocCkge1xuICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHt9LCBwLCBiaW5kRkcubGlua01ldGhvZChwKSk7XG59KSkpO1xuZnVuY3Rpb24gYWRqdXN0Q2FudmFzU2l6ZShzdGF0ZSkge1xuICBpZiAoc3RhdGUuY2FudmFzKSB7XG4gICAgdmFyIGN1cldpZHRoID0gc3RhdGUuY2FudmFzLndpZHRoO1xuICAgIHZhciBjdXJIZWlnaHQgPSBzdGF0ZS5jYW52YXMuaGVpZ2h0O1xuICAgIGlmIChjdXJXaWR0aCA9PT0gMzAwICYmIGN1ckhlaWdodCA9PT0gMTUwKSB7XG4gICAgICAvLyBEZWZhdWx0IGNhbnZhcyBkaW1lbnNpb25zXG4gICAgICBjdXJXaWR0aCA9IGN1ckhlaWdodCA9IDA7XG4gICAgfVxuICAgIHZhciBweFNjYWxlID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87IC8vIDIgb24gcmV0aW5hIGRpc3BsYXlzXG4gICAgY3VyV2lkdGggLz0gcHhTY2FsZTtcbiAgICBjdXJIZWlnaHQgLz0gcHhTY2FsZTtcblxuICAgIC8vIFJlc2l6ZSBjYW52YXNlc1xuICAgIFtzdGF0ZS5jYW52YXMsIHN0YXRlLnNoYWRvd0NhbnZhc10uZm9yRWFjaChmdW5jdGlvbiAoY2FudmFzKSB7XG4gICAgICAvLyBFbGVtZW50IHNpemVcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KHN0YXRlLndpZHRoLCBcInB4XCIpO1xuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KHN0YXRlLmhlaWdodCwgXCJweFwiKTtcblxuICAgICAgLy8gTWVtb3J5IHNpemUgKHNjYWxlZCB0byBhdm9pZCBibHVycmluZXNzKVxuICAgICAgY2FudmFzLndpZHRoID0gc3RhdGUud2lkdGggKiBweFNjYWxlO1xuICAgICAgY2FudmFzLmhlaWdodCA9IHN0YXRlLmhlaWdodCAqIHB4U2NhbGU7XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSBjb29yZGluYXRlIHN5c3RlbSB0byB1c2UgY3NzIHBpeGVscyAob24gaW5pdCBvbmx5KVxuICAgICAgaWYgKCFjdXJXaWR0aCAmJiAhY3VySGVpZ2h0KSB7XG4gICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLnNjYWxlKHB4U2NhbGUsIHB4U2NhbGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmVsYXRpdmUgY2VudGVyIHBhbm5pbmcgYmFzZWQgb24gMCwwXG4gICAgdmFyIGsgPSB6b29tVHJhbnNmb3JtKHN0YXRlLmNhbnZhcykuaztcbiAgICBzdGF0ZS56b29tLnRyYW5zbGF0ZUJ5KHN0YXRlLnpvb20uX19iYXNlRWxlbSwgKHN0YXRlLndpZHRoIC0gY3VyV2lkdGgpIC8gMiAvIGssIChzdGF0ZS5oZWlnaHQgLSBjdXJIZWlnaHQpIC8gMiAvIGspO1xuICAgIHN0YXRlLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzZXRUcmFuc2Zvcm0oY3R4KSB7XG4gIHZhciBweFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIGN0eC5zZXRUcmFuc2Zvcm0ocHhSYXRpbywgMCwgMCwgcHhSYXRpbywgMCwgMCk7XG59XG5mdW5jdGlvbiBjbGVhckNhbnZhcyhjdHgsIHdpZHRoLCBoZWlnaHQpIHtcbiAgY3R4LnNhdmUoKTtcbiAgcmVzZXRUcmFuc2Zvcm0oY3R4KTsgLy8gcmVzZXQgdHJhbnNmb3JtXG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gIGN0eC5yZXN0b3JlKCk7IC8vcmVzdG9yZSB0cmFuc2Zvcm1zXG59XG5cbi8vXG5cbnZhciBmb3JjZUdyYXBoID0gS2Fwc3VsZSh7XG4gIHByb3BzOiBfb2JqZWN0U3ByZWFkMih7XG4gICAgd2lkdGg6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShfLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gYWRqdXN0Q2FudmFzU2l6ZShzdGF0ZSk7XG4gICAgICB9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGhlaWdodDoge1xuICAgICAgXCJkZWZhdWx0XCI6IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShfLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gYWRqdXN0Q2FudmFzU2l6ZShzdGF0ZSk7XG4gICAgICB9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGdyYXBoRGF0YToge1xuICAgICAgXCJkZWZhdWx0XCI6IHtcbiAgICAgICAgbm9kZXM6IFtdLFxuICAgICAgICBsaW5rczogW11cbiAgICAgIH0sXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoZCwgc3RhdGUpIHtcbiAgICAgICAgLy8gV2lwZSBjb2xvciByZWdpc3RyeSBpZiBhbGwgb2JqZWN0cyBhcmUgbmV3XG4gICAgICAgIFtkLm5vZGVzLCBkLmxpbmtzXS5ldmVyeShmdW5jdGlvbiAoYXJyKSB7XG4gICAgICAgICAgcmV0dXJuIChhcnIgfHwgW10pLmV2ZXJ5KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gIWQuaGFzT3duUHJvcGVydHkoJ19faW5kZXhDb2xvcicpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSAmJiBzdGF0ZS5jb2xvclRyYWNrZXIucmVzZXQoKTtcbiAgICAgICAgW3tcbiAgICAgICAgICB0eXBlOiAnTm9kZScsXG4gICAgICAgICAgb2JqczogZC5ub2Rlc1xuICAgICAgICB9LCB7XG4gICAgICAgICAgdHlwZTogJ0xpbmsnLFxuICAgICAgICAgIG9ianM6IGQubGlua3NcbiAgICAgICAgfV0uZm9yRWFjaChoZXhJbmRleCk7XG4gICAgICAgIHN0YXRlLmZvcmNlR3JhcGguZ3JhcGhEYXRhKGQpO1xuICAgICAgICBzdGF0ZS5zaGFkb3dHcmFwaC5ncmFwaERhdGEoZCk7XG4gICAgICAgIGZ1bmN0aW9uIGhleEluZGV4KF9yZWY0KSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBfcmVmNC50eXBlLFxuICAgICAgICAgICAgb2JqcyA9IF9yZWY0Lm9ianM7XG4gICAgICAgICAgb2Jqcy5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGlmICghZC5oYXNPd25Qcm9wZXJ0eSgnX19pbmRleENvbG9yJykpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgdmFyIGN1ciA9IHN0YXRlLmNvbG9yVHJhY2tlci5sb29rdXAoZC5fX2luZGV4Q29sb3IpO1xuICAgICAgICAgICAgcmV0dXJuICFjdXIgfHwgIWN1ci5oYXNPd25Qcm9wZXJ0eSgnZCcpIHx8IGN1ci5kICE9PSBkO1xuICAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIC8vIHN0b3JlIG9iamVjdCBsb29rdXAgY29sb3JcbiAgICAgICAgICAgIGQuX19pbmRleENvbG9yID0gc3RhdGUuY29sb3JUcmFja2VyLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgZDogZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgYmFja2dyb3VuZENvbG9yOiB7XG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoY29sb3IsIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLmNhbnZhcyAmJiBjb2xvciAmJiAoc3RhdGUuY2FudmFzLnN0eWxlLmJhY2tncm91bmQgPSBjb2xvcik7XG4gICAgICB9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG5vZGVMYWJlbDoge1xuICAgICAgXCJkZWZhdWx0XCI6ICduYW1lJyxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBub2RlUG9pbnRlckFyZWFQYWludDoge1xuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKHBhaW50Rm4sIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLnNoYWRvd0dyYXBoLm5vZGVDYW52YXNPYmplY3QoIXBhaW50Rm4gPyBudWxsIDogZnVuY3Rpb24gKG5vZGUsIGN0eCwgZ2xvYmFsU2NhbGUpIHtcbiAgICAgICAgICByZXR1cm4gcGFpbnRGbihub2RlLCBub2RlLl9faW5kZXhDb2xvciwgY3R4LCBnbG9iYWxTY2FsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0ZS5mbHVzaFNoYWRvd0NhbnZhcyAmJiBzdGF0ZS5mbHVzaFNoYWRvd0NhbnZhcygpO1xuICAgICAgfSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBsaW5rUG9pbnRlckFyZWFQYWludDoge1xuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKHBhaW50Rm4sIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLnNoYWRvd0dyYXBoLmxpbmtDYW52YXNPYmplY3QoIXBhaW50Rm4gPyBudWxsIDogZnVuY3Rpb24gKGxpbmssIGN0eCwgZ2xvYmFsU2NhbGUpIHtcbiAgICAgICAgICByZXR1cm4gcGFpbnRGbihsaW5rLCBsaW5rLl9faW5kZXhDb2xvciwgY3R4LCBnbG9iYWxTY2FsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0ZS5mbHVzaFNoYWRvd0NhbnZhcyAmJiBzdGF0ZS5mbHVzaFNoYWRvd0NhbnZhcygpO1xuICAgICAgfSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBsaW5rTGFiZWw6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAnbmFtZScsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgbGlua0hvdmVyUHJlY2lzaW9uOiB7XG4gICAgICBcImRlZmF1bHRcIjogNCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBtaW5ab29tOiB7XG4gICAgICBcImRlZmF1bHRcIjogMC4wMSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShtaW5ab29tLCBzdGF0ZSkge1xuICAgICAgICBzdGF0ZS56b29tLnNjYWxlRXh0ZW50KFttaW5ab29tLCBzdGF0ZS56b29tLnNjYWxlRXh0ZW50KClbMV1dKTtcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgbWF4Wm9vbToge1xuICAgICAgXCJkZWZhdWx0XCI6IDEwMDAsXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UobWF4Wm9vbSwgc3RhdGUpIHtcbiAgICAgICAgc3RhdGUuem9vbS5zY2FsZUV4dGVudChbc3RhdGUuem9vbS5zY2FsZUV4dGVudCgpWzBdLCBtYXhab29tXSk7XG4gICAgICB9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGVuYWJsZU5vZGVEcmFnOiB7XG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBlbmFibGVab29tSW50ZXJhY3Rpb246IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGVuYWJsZVBhbkludGVyYWN0aW9uOiB7XG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBlbmFibGVab29tUGFuSW50ZXJhY3Rpb246IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIC8vIHRvIGJlIGRlcHJlY2F0ZWRcbiAgICBlbmFibGVQb2ludGVySW50ZXJhY3Rpb246IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKF8sIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLmhvdmVyT2JqID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgYXV0b1BhdXNlUmVkcmF3OiB7XG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbk5vZGVEcmFnOiB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7fSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbk5vZGVEcmFnRW5kOiB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7fSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbk5vZGVDbGljazoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uTm9kZVJpZ2h0Q2xpY2s6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbk5vZGVIb3Zlcjoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uTGlua0NsaWNrOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25MaW5rUmlnaHRDbGljazoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uTGlua0hvdmVyOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25CYWNrZ3JvdW5kQ2xpY2s6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbkJhY2tncm91bmRSaWdodENsaWNrOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgc2hvd1BvaW50ZXJDdXJzb3I6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uWm9vbToge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uWm9vbUVuZDoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uUmVuZGVyRnJhbWVQcmU6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvblJlbmRlckZyYW1lUG9zdDoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9XG4gIH0sIGxpbmtlZFByb3BzKSxcbiAgYWxpYXNlczoge1xuICAgIC8vIFByb3AgbmFtZXMgc3VwcG9ydGVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIHN0b3BBbmltYXRpb246ICdwYXVzZUFuaW1hdGlvbidcbiAgfSxcbiAgbWV0aG9kczogX29iamVjdFNwcmVhZDIoe1xuICAgIGdyYXBoMlNjcmVlbkNvb3JkczogZnVuY3Rpb24gZ3JhcGgyU2NyZWVuQ29vcmRzKHN0YXRlLCB4LCB5KSB7XG4gICAgICB2YXIgdCA9IHpvb21UcmFuc2Zvcm0oc3RhdGUuY2FudmFzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggKiB0LmsgKyB0LngsXG4gICAgICAgIHk6IHkgKiB0LmsgKyB0LnlcbiAgICAgIH07XG4gICAgfSxcbiAgICBzY3JlZW4yR3JhcGhDb29yZHM6IGZ1bmN0aW9uIHNjcmVlbjJHcmFwaENvb3JkcyhzdGF0ZSwgeCwgeSkge1xuICAgICAgdmFyIHQgPSB6b29tVHJhbnNmb3JtKHN0YXRlLmNhbnZhcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAoeCAtIHQueCkgLyB0LmssXG4gICAgICAgIHk6ICh5IC0gdC55KSAvIHQua1xuICAgICAgfTtcbiAgICB9LFxuICAgIGNlbnRlckF0OiBmdW5jdGlvbiBjZW50ZXJBdChzdGF0ZSwgeCwgeSwgdHJhbnNpdGlvbkR1cmF0aW9uKSB7XG4gICAgICBpZiAoIXN0YXRlLmNhbnZhcykgcmV0dXJuIG51bGw7IC8vIG5vIGNhbnZhcyB5ZXRcblxuICAgICAgLy8gc2V0dGVyXG4gICAgICBpZiAoeCAhPT0gdW5kZWZpbmVkIHx8IHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZmluYWxQb3MgPSBPYmplY3QuYXNzaWduKHt9LCB4ICE9PSB1bmRlZmluZWQgPyB7XG4gICAgICAgICAgeDogeFxuICAgICAgICB9IDoge30sIHkgIT09IHVuZGVmaW5lZCA/IHtcbiAgICAgICAgICB5OiB5XG4gICAgICAgIH0gOiB7fSk7XG4gICAgICAgIGlmICghdHJhbnNpdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICAgLy8gbm8gYW5pbWF0aW9uXG4gICAgICAgICAgc2V0Q2VudGVyKGZpbmFsUG9zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS50d2Vlbkdyb3VwLmFkZChuZXcgVHdlZW4oZ2V0Q2VudGVyKCkpLnRvKGZpbmFsUG9zLCB0cmFuc2l0aW9uRHVyYXRpb24pLmVhc2luZyhFYXNpbmcuUXVhZHJhdGljLk91dCkub25VcGRhdGUoc2V0Q2VudGVyKS5zdGFydCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZ2V0dGVyXG4gICAgICByZXR1cm4gZ2V0Q2VudGVyKCk7XG5cbiAgICAgIC8vXG5cbiAgICAgIGZ1bmN0aW9uIGdldENlbnRlcigpIHtcbiAgICAgICAgdmFyIHQgPSB6b29tVHJhbnNmb3JtKHN0YXRlLmNhbnZhcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogKHN0YXRlLndpZHRoIC8gMiAtIHQueCkgLyB0LmssXG4gICAgICAgICAgeTogKHN0YXRlLmhlaWdodCAvIDIgLSB0LnkpIC8gdC5rXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzZXRDZW50ZXIoX3JlZjUpIHtcbiAgICAgICAgdmFyIHggPSBfcmVmNS54LFxuICAgICAgICAgIHkgPSBfcmVmNS55O1xuICAgICAgICBzdGF0ZS56b29tLnRyYW5zbGF0ZVRvKHN0YXRlLnpvb20uX19iYXNlRWxlbSwgeCA9PT0gdW5kZWZpbmVkID8gZ2V0Q2VudGVyKCkueCA6IHgsIHkgPT09IHVuZGVmaW5lZCA/IGdldENlbnRlcigpLnkgOiB5KTtcbiAgICAgICAgc3RhdGUubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgem9vbTogZnVuY3Rpb24gem9vbShzdGF0ZSwgaywgdHJhbnNpdGlvbkR1cmF0aW9uKSB7XG4gICAgICBpZiAoIXN0YXRlLmNhbnZhcykgcmV0dXJuIG51bGw7IC8vIG5vIGNhbnZhcyB5ZXRcblxuICAgICAgLy8gc2V0dGVyXG4gICAgICBpZiAoayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghdHJhbnNpdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICAgLy8gbm8gYW5pbWF0aW9uXG4gICAgICAgICAgc2V0Wm9vbShrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS50d2Vlbkdyb3VwLmFkZChuZXcgVHdlZW4oe1xuICAgICAgICAgICAgazogZ2V0Wm9vbSgpXG4gICAgICAgICAgfSkudG8oe1xuICAgICAgICAgICAgazoga1xuICAgICAgICAgIH0sIHRyYW5zaXRpb25EdXJhdGlvbikuZWFzaW5nKEVhc2luZy5RdWFkcmF0aWMuT3V0KS5vblVwZGF0ZShmdW5jdGlvbiAoX3JlZjYpIHtcbiAgICAgICAgICAgIHZhciBrID0gX3JlZjYuaztcbiAgICAgICAgICAgIHJldHVybiBzZXRab29tKGspO1xuICAgICAgICAgIH0pLnN0YXJ0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXR0ZXJcbiAgICAgIHJldHVybiBnZXRab29tKCk7XG5cbiAgICAgIC8vXG5cbiAgICAgIGZ1bmN0aW9uIGdldFpvb20oKSB7XG4gICAgICAgIHJldHVybiB6b29tVHJhbnNmb3JtKHN0YXRlLmNhbnZhcykuaztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHNldFpvb20oaykge1xuICAgICAgICBzdGF0ZS56b29tLnNjYWxlVG8oc3RhdGUuem9vbS5fX2Jhc2VFbGVtLCBrKTtcbiAgICAgICAgc3RhdGUubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgem9vbVRvRml0OiBmdW5jdGlvbiB6b29tVG9GaXQoc3RhdGUpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTA7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYmJveEFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDMgPyBfbGVuIC0gMyA6IDApLCBfa2V5ID0gMzsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBiYm94QXJnc1tfa2V5IC0gM10gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICB2YXIgYmJveCA9IHRoaXMuZ2V0R3JhcGhCYm94LmFwcGx5KHRoaXMsIGJib3hBcmdzKTtcbiAgICAgIGlmIChiYm94KSB7XG4gICAgICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICAgICAgeDogKGJib3gueFswXSArIGJib3gueFsxXSkgLyAyLFxuICAgICAgICAgIHk6IChiYm94LnlbMF0gKyBiYm94LnlbMV0pIC8gMlxuICAgICAgICB9O1xuICAgICAgICB2YXIgem9vbUsgPSBNYXRoLm1heCgxZS0xMiwgTWF0aC5taW4oMWUxMiwgKHN0YXRlLndpZHRoIC0gcGFkZGluZyAqIDIpIC8gKGJib3gueFsxXSAtIGJib3gueFswXSksIChzdGF0ZS5oZWlnaHQgLSBwYWRkaW5nICogMikgLyAoYmJveC55WzFdIC0gYmJveC55WzBdKSkpO1xuICAgICAgICB0aGlzLmNlbnRlckF0KGNlbnRlci54LCBjZW50ZXIueSwgdHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy56b29tKHpvb21LLCB0cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXRHcmFwaEJib3g6IGZ1bmN0aW9uIGdldEdyYXBoQmJveChzdGF0ZSkge1xuICAgICAgdmFyIG5vZGVGaWx0ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgICAgdmFyIGdldFZhbCA9IGFjY2Vzc29yRm4oc3RhdGUubm9kZVZhbCk7XG4gICAgICB2YXIgZ2V0UiA9IGZ1bmN0aW9uIGdldFIobm9kZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIGdldFZhbChub2RlKSB8fCAxKSkgKiBzdGF0ZS5ub2RlUmVsU2l6ZTtcbiAgICAgIH07XG4gICAgICB2YXIgbm9kZXNQb3MgPSBzdGF0ZS5ncmFwaERhdGEubm9kZXMuZmlsdGVyKG5vZGVGaWx0ZXIpLm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IG5vZGUueCxcbiAgICAgICAgICB5OiBub2RlLnksXG4gICAgICAgICAgcjogZ2V0Uihub2RlKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gIW5vZGVzUG9zLmxlbmd0aCA/IG51bGwgOiB7XG4gICAgICAgIHg6IFttaW4obm9kZXNQb3MsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUueCAtIG5vZGUucjtcbiAgICAgICAgfSksIG1heChub2Rlc1BvcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS54ICsgbm9kZS5yO1xuICAgICAgICB9KV0sXG4gICAgICAgIHk6IFttaW4obm9kZXNQb3MsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUueSAtIG5vZGUucjtcbiAgICAgICAgfSksIG1heChub2Rlc1BvcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS55ICsgbm9kZS5yO1xuICAgICAgICB9KV1cbiAgICAgIH07XG4gICAgfSxcbiAgICBwYXVzZUFuaW1hdGlvbjogZnVuY3Rpb24gcGF1c2VBbmltYXRpb24oc3RhdGUpIHtcbiAgICAgIGlmIChzdGF0ZS5hbmltYXRpb25GcmFtZVJlcXVlc3RJZCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShzdGF0ZS5hbmltYXRpb25GcmFtZVJlcXVlc3RJZCk7XG4gICAgICAgIHN0YXRlLmFuaW1hdGlvbkZyYW1lUmVxdWVzdElkID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVzdW1lQW5pbWF0aW9uOiBmdW5jdGlvbiByZXN1bWVBbmltYXRpb24oc3RhdGUpIHtcbiAgICAgIGlmICghc3RhdGUuYW5pbWF0aW9uRnJhbWVSZXF1ZXN0SWQpIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uQ3ljbGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgX2Rlc3RydWN0b3I6IGZ1bmN0aW9uIF9kZXN0cnVjdG9yKCkge1xuICAgICAgdGhpcy5wYXVzZUFuaW1hdGlvbigpO1xuICAgICAgdGhpcy5ncmFwaERhdGEoe1xuICAgICAgICBub2RlczogW10sXG4gICAgICAgIGxpbmtzOiBbXVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBsaW5rZWRNZXRob2RzKSxcbiAgc3RhdGVJbml0OiBmdW5jdGlvbiBzdGF0ZUluaXQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhc3RTZXRab29tOiAxLFxuICAgICAgem9vbTogem9vbSgpLFxuICAgICAgZm9yY2VHcmFwaDogbmV3IENhbnZhc0ZvcmNlR3JhcGgoKSxcbiAgICAgIHNoYWRvd0dyYXBoOiBuZXcgQ2FudmFzRm9yY2VHcmFwaCgpLmNvb2xkb3duVGlja3MoMCkubm9kZUNvbG9yKCdfX2luZGV4Q29sb3InKS5saW5rQ29sb3IoJ19faW5kZXhDb2xvcicpLmlzU2hhZG93KHRydWUpLFxuICAgICAgY29sb3JUcmFja2VyOiBuZXcgQ29sb3JUcmFja2VyKCksXG4gICAgICAvLyBpbmRleGVkIG9iamVjdHMgZm9yIHJnYiBsb29rdXBcbiAgICAgIHR3ZWVuR3JvdXA6IG5ldyBHcm91cCgpXG4gICAgfTtcbiAgfSxcbiAgaW5pdDogZnVuY3Rpb24gaW5pdChkb21Ob2RlLCBzdGF0ZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgLy8gV2lwZSBET01cbiAgICBkb21Ob2RlLmlubmVySFRNTCA9ICcnO1xuXG4gICAgLy8gQ29udGFpbmVyIGFuY2hvciBmb3IgY2FudmFzIGFuZCB0b29sdGlwXG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdmb3JjZS1ncmFwaC1jb250YWluZXInKTtcbiAgICBjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIGRvbU5vZGUuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICBzdGF0ZS5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBpZiAoc3RhdGUuYmFja2dyb3VuZENvbG9yKSBzdGF0ZS5jYW52YXMuc3R5bGUuYmFja2dyb3VuZCA9IHN0YXRlLmJhY2tncm91bmRDb2xvcjtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoc3RhdGUuY2FudmFzKTtcbiAgICBzdGF0ZS5zaGFkb3dDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgIC8vIFNob3cgc2hhZG93IGNhbnZhc1xuICAgIC8vc3RhdGUuc2hhZG93Q2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAvL3N0YXRlLnNoYWRvd0NhbnZhcy5zdHlsZS50b3AgPSAnMCc7XG4gICAgLy9zdGF0ZS5zaGFkb3dDYW52YXMuc3R5bGUubGVmdCA9ICcwJztcbiAgICAvL2NvbnRhaW5lci5hcHBlbmRDaGlsZChzdGF0ZS5zaGFkb3dDYW52YXMpO1xuXG4gICAgdmFyIGN0eCA9IHN0YXRlLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciBzaGFkb3dDdHggPSBzdGF0ZS5zaGFkb3dDYW52YXMuZ2V0Q29udGV4dCgnMmQnLCB7XG4gICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbiAgICB9KTtcbiAgICB2YXIgcG9pbnRlclBvcyA9IHtcbiAgICAgIHg6IC0xZTEyLFxuICAgICAgeTogLTFlMTJcbiAgICB9O1xuICAgIHZhciBnZXRPYmpVbmRlclBvaW50ZXIgPSBmdW5jdGlvbiBnZXRPYmpVbmRlclBvaW50ZXIoKSB7XG4gICAgICB2YXIgb2JqID0gbnVsbDtcbiAgICAgIHZhciBweFNjYWxlID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICB2YXIgcHggPSBwb2ludGVyUG9zLnggPiAwICYmIHBvaW50ZXJQb3MueSA+IDAgPyBzaGFkb3dDdHguZ2V0SW1hZ2VEYXRhKHBvaW50ZXJQb3MueCAqIHB4U2NhbGUsIHBvaW50ZXJQb3MueSAqIHB4U2NhbGUsIDEsIDEpIDogbnVsbDtcbiAgICAgIC8vIExvb2t1cCBvYmplY3QgcGVyIHBpeGVsIGNvbG9yXG4gICAgICBweCAmJiAob2JqID0gc3RhdGUuY29sb3JUcmFja2VyLmxvb2t1cChweC5kYXRhKSk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICAvLyBTZXR1cCBub2RlIGRyYWcgaW50ZXJhY3Rpb25cbiAgICBzZWxlY3Qoc3RhdGUuY2FudmFzKS5jYWxsKGRyYWcoKS5zdWJqZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3RhdGUuZW5hYmxlTm9kZURyYWcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0gZ2V0T2JqVW5kZXJQb2ludGVyKCk7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai50eXBlID09PSAnTm9kZScgPyBvYmouZCA6IG51bGw7IC8vIE9ubHkgZHJhZyBub2Rlc1xuICAgIH0pLm9uKCdzdGFydCcsIGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIG9iaiA9IGV2LnN1YmplY3Q7XG4gICAgICBvYmouX19pbml0aWFsRHJhZ1BvcyA9IHtcbiAgICAgICAgeDogb2JqLngsXG4gICAgICAgIHk6IG9iai55LFxuICAgICAgICBmeDogb2JqLmZ4LFxuICAgICAgICBmeTogb2JqLmZ5XG4gICAgICB9O1xuXG4gICAgICAvLyBrZWVwIGVuZ2luZSBydW5uaW5nIGF0IGxvdyBpbnRlbnNpdHkgdGhyb3VnaG91dCBkcmFnXG4gICAgICBpZiAoIWV2LmFjdGl2ZSkge1xuICAgICAgICBvYmouZnggPSBvYmoueDtcbiAgICAgICAgb2JqLmZ5ID0gb2JqLnk7IC8vIEZpeCBwb2ludHNcbiAgICAgIH1cblxuICAgICAgLy8gZHJhZyBjdXJzb3JcbiAgICAgIHN0YXRlLmNhbnZhcy5jbGFzc0xpc3QuYWRkKCdncmFiYmFibGUnKTtcbiAgICB9KS5vbignZHJhZycsIGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIG9iaiA9IGV2LnN1YmplY3Q7XG4gICAgICB2YXIgaW5pdFBvcyA9IG9iai5fX2luaXRpYWxEcmFnUG9zO1xuICAgICAgdmFyIGRyYWdQb3MgPSBldjtcbiAgICAgIHZhciBrID0gem9vbVRyYW5zZm9ybShzdGF0ZS5jYW52YXMpLms7XG4gICAgICB2YXIgdHJhbnNsYXRlID0ge1xuICAgICAgICB4OiBpbml0UG9zLnggKyAoZHJhZ1Bvcy54IC0gaW5pdFBvcy54KSAvIGsgLSBvYmoueCxcbiAgICAgICAgeTogaW5pdFBvcy55ICsgKGRyYWdQb3MueSAtIGluaXRQb3MueSkgLyBrIC0gb2JqLnlcbiAgICAgIH07XG5cbiAgICAgIC8vIE1vdmUgZngvZnkgKGFuZCB4L3kpIG9mIG5vZGVzIGJhc2VkIG9uIHRoZSBzY2FsZWQgZHJhZyBkaXN0YW5jZSBzaW5jZSB0aGUgZHJhZyBzdGFydFxuICAgICAgWyd4JywgJ3knXS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBvYmpbXCJmXCIuY29uY2F0KGMpXSA9IG9ialtjXSA9IGluaXRQb3NbY10gKyAoZHJhZ1Bvc1tjXSAtIGluaXRQb3NbY10pIC8gaztcbiAgICAgIH0pO1xuXG4gICAgICAvLyBPbmx5IGVuZ2FnZSBmdWxsIGRyYWcgaWYgZGlzdGFuY2UgcmVhY2hlcyBhYm92ZSB0aHJlc2hvbGRcbiAgICAgIGlmICghb2JqLl9fZHJhZ2dlZCAmJiBEUkFHX0NMSUNLX1RPTEVSQU5DRV9QWCA+PSBNYXRoLnNxcnQoc3VtKFsneCcsICd5J10ubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnBvdyhldltrXSAtIGluaXRQb3Nba10sIDIpO1xuICAgICAgfSkpKSkgcmV0dXJuO1xuICAgICAgc3RhdGUuZm9yY2VHcmFwaC5kM0FscGhhVGFyZ2V0KDAuMykgLy8ga2VlcCBlbmdpbmUgcnVubmluZyBhdCBsb3cgaW50ZW5zaXR5IHRocm91Z2hvdXQgZHJhZ1xuICAgICAgLnJlc2V0Q291bnRkb3duKCk7IC8vIHByZXZlbnQgZnJlZXplIHdoaWxlIGRyYWdnaW5nXG5cbiAgICAgIHN0YXRlLmlzUG9pbnRlckRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgIG9iai5fX2RyYWdnZWQgPSB0cnVlO1xuICAgICAgc3RhdGUub25Ob2RlRHJhZyhvYmosIHRyYW5zbGF0ZSk7XG4gICAgfSkub24oJ2VuZCcsIGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIG9iaiA9IGV2LnN1YmplY3Q7XG4gICAgICB2YXIgaW5pdFBvcyA9IG9iai5fX2luaXRpYWxEcmFnUG9zO1xuICAgICAgdmFyIHRyYW5zbGF0ZSA9IHtcbiAgICAgICAgeDogb2JqLnggLSBpbml0UG9zLngsXG4gICAgICAgIHk6IG9iai55IC0gaW5pdFBvcy55XG4gICAgICB9O1xuICAgICAgaWYgKGluaXRQb3MuZnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvYmouZnggPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoaW5pdFBvcy5meSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9iai5meSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBvYmouX19pbml0aWFsRHJhZ1BvcztcbiAgICAgIGlmIChzdGF0ZS5mb3JjZUdyYXBoLmQzQWxwaGFUYXJnZXQoKSkge1xuICAgICAgICBzdGF0ZS5mb3JjZUdyYXBoLmQzQWxwaGFUYXJnZXQoMCkgLy8gcmVsZWFzZSBlbmdpbmUgbG93IGludGVuc2l0eVxuICAgICAgICAucmVzZXRDb3VudGRvd24oKTsgLy8gbGV0IHRoZSBlbmdpbmUgcmVhZGp1c3QgYWZ0ZXIgcmVsZWFzaW5nIGZpeGVkIG5vZGVzXG4gICAgICB9XG5cbiAgICAgIC8vIGRyYWcgY3Vyc29yXG4gICAgICBzdGF0ZS5jYW52YXMuY2xhc3NMaXN0LnJlbW92ZSgnZ3JhYmJhYmxlJyk7XG4gICAgICBzdGF0ZS5pc1BvaW50ZXJEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgaWYgKG9iai5fX2RyYWdnZWQpIHtcbiAgICAgICAgZGVsZXRlIG9iai5fX2RyYWdnZWQ7XG4gICAgICAgIHN0YXRlLm9uTm9kZURyYWdFbmQob2JqLCB0cmFuc2xhdGUpO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIC8vIFNldHVwIHpvb20gLyBwYW4gaW50ZXJhY3Rpb25cbiAgICBzdGF0ZS56b29tKHN0YXRlLnpvb20uX19iYXNlRWxlbSA9IHNlbGVjdChzdGF0ZS5jYW52YXMpKTsgLy8gQXR0YWNoIGNvbnRyb2xsaW5nIGVsZW0gZm9yIGVhc3kgYWNjZXNzXG5cbiAgICBzdGF0ZS56b29tLl9fYmFzZUVsZW0ub24oJ2RibGNsaWNrLnpvb20nLCBudWxsKTsgLy8gRGlzYWJsZSBkb3VibGUtY2xpY2sgdG8gem9vbVxuXG4gICAgc3RhdGUuem9vbS5maWx0ZXIoZnVuY3Rpb24gKGV2KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAvLyBkaXNhYmxlIHpvb20gaW50ZXJhY3Rpb25cbiAgICAgICAgIWV2LmJ1dHRvbiAmJiBzdGF0ZS5lbmFibGVab29tUGFuSW50ZXJhY3Rpb24gJiYgKGV2LnR5cGUgIT09ICd3aGVlbCcgfHwgYWNjZXNzb3JGbihzdGF0ZS5lbmFibGVab29tSW50ZXJhY3Rpb24pKGV2KSkgJiYgKGV2LnR5cGUgPT09ICd3aGVlbCcgfHwgYWNjZXNzb3JGbihzdGF0ZS5lbmFibGVQYW5JbnRlcmFjdGlvbikoZXYpKVxuICAgICAgKTtcbiAgICB9KS5vbignem9vbScsIGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIHQgPSBldi50cmFuc2Zvcm07XG4gICAgICBbY3R4LCBzaGFkb3dDdHhdLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmVzZXRUcmFuc2Zvcm0oYyk7XG4gICAgICAgIGMudHJhbnNsYXRlKHQueCwgdC55KTtcbiAgICAgICAgYy5zY2FsZSh0LmssIHQuayk7XG4gICAgICB9KTtcbiAgICAgIHN0YXRlLmlzUG9pbnRlckRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgIHN0YXRlLm9uWm9vbSAmJiBzdGF0ZS5vblpvb20oX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHQpLCBfdGhpcy5jZW50ZXJBdCgpKSk7IC8vIHJlcG9ydCB4LHkgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gY2FudmFzIGNlbnRlclxuICAgICAgc3RhdGUubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgIH0pLm9uKCdlbmQnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHN0YXRlLmlzUG9pbnRlckRyYWdnaW5nID0gZmFsc2U7XG4gICAgICBzdGF0ZS5vblpvb21FbmQgJiYgc3RhdGUub25ab29tRW5kKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBldi50cmFuc2Zvcm0pLCBfdGhpcy5jZW50ZXJBdCgpKSk7XG4gICAgfSk7XG4gICAgYWRqdXN0Q2FudmFzU2l6ZShzdGF0ZSk7XG4gICAgc3RhdGUuZm9yY2VHcmFwaC5vbk5lZWRzUmVkcmF3KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgfSkub25GaW5pc2hVcGRhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gcmUtem9vbSwgaWYgc3RpbGwgaW4gZGVmYXVsdCBwb3NpdGlvbiAobm90IHVzZXIgbW9kaWZpZWQpXG4gICAgICBpZiAoem9vbVRyYW5zZm9ybShzdGF0ZS5jYW52YXMpLmsgPT09IHN0YXRlLmxhc3RTZXRab29tICYmIHN0YXRlLmdyYXBoRGF0YS5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgc3RhdGUuem9vbS5zY2FsZVRvKHN0YXRlLnpvb20uX19iYXNlRWxlbSwgc3RhdGUubGFzdFNldFpvb20gPSBaT09NMk5PREVTX0ZBQ1RPUiAvIE1hdGguY2JydChzdGF0ZS5ncmFwaERhdGEubm9kZXMubGVuZ3RoKSk7XG4gICAgICAgIHN0YXRlLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNldHVwIHRvb2x0aXBcbiAgICBzdGF0ZS50b29sdGlwID0gbmV3IFRvb2x0aXAoY29udGFpbmVyKTtcblxuICAgIC8vIENhcHR1cmUgcG9pbnRlciBjb29yZHMgb24gbW92ZSBvciB0b3VjaHN0YXJ0XG4gICAgWydwb2ludGVybW92ZScsICdwb2ludGVyZG93biddLmZvckVhY2goZnVuY3Rpb24gKGV2VHlwZSkge1xuICAgICAgcmV0dXJuIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKGV2VHlwZSwgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIGlmIChldlR5cGUgPT09ICdwb2ludGVyZG93bicpIHtcbiAgICAgICAgICBzdGF0ZS5pc1BvaW50ZXJQcmVzc2VkID0gdHJ1ZTsgLy8gdHJhY2sgY2xpY2sgc3RhdGVcbiAgICAgICAgICBzdGF0ZS5wb2ludGVyRG93bkV2ZW50ID0gZXY7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZXRlY3QgcG9pbnRlciBkcmFnIG9uIGNhbnZhcyBwYW5cbiAgICAgICAgIXN0YXRlLmlzUG9pbnRlckRyYWdnaW5nICYmIGV2LnR5cGUgPT09ICdwb2ludGVybW92ZScgJiYgc3RhdGUub25CYWNrZ3JvdW5kQ2xpY2sgLy8gb25seSBib3RoZXIgZGV0ZWN0aW5nIGRyYWdzIHRoaXMgd2F5IGlmIGJhY2tncm91bmQgY2xpY2tzIGFyZSBlbmFibGVkIChzbyB0aGV5IGRvbid0IHRyaWdnZXIgYWNjaWRlbnRhbGx5IG9uIGNhbnZhcyBwYW5uaW5nKVxuICAgICAgICAmJiAoZXYucHJlc3N1cmUgPiAwIHx8IHN0YXRlLmlzUG9pbnRlclByZXNzZWQpIC8vIGV2LnByZXNzdXJlIGFsd2F5cyAwIG9uIFNhZmFyaSwgc28gd2UgdXNlIHRoZSBpc1BvaW50ZXJQcmVzc2VkIHRyYWNrZXJcbiAgICAgICAgJiYgKGV2LnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IGV2Lm1vdmVtZW50WCA9PT0gdW5kZWZpbmVkIHx8IFtldi5tb3ZlbWVudFgsIGV2Lm1vdmVtZW50WV0uc29tZShmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmFicyhtKSA+IDE7XG4gICAgICAgIH0pKSAvLyByZWxheCBkcmFnIHRyaWdnZXIgc2Vuc2l0aXZpdHkgb24gbm9uLW1vdXNlICh0b3VjaC9wZW4pIGV2ZW50c1xuICAgICAgICAmJiAoc3RhdGUuaXNQb2ludGVyRHJhZ2dpbmcgPSB0cnVlKTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHBvaW50ZXIgcG9zXG4gICAgICAgIHZhciBvZmZzZXQgPSBnZXRPZmZzZXQoY29udGFpbmVyKTtcbiAgICAgICAgcG9pbnRlclBvcy54ID0gZXYucGFnZVggLSBvZmZzZXQubGVmdDtcbiAgICAgICAgcG9pbnRlclBvcy55ID0gZXYucGFnZVkgLSBvZmZzZXQudG9wO1xuXG4gICAgICAgIC8vXG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0T2Zmc2V0KGVsKSB7XG4gICAgICAgICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIHNjcm9sbExlZnQgPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICAgICAgICBzY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCArIHNjcm9sbFRvcCxcbiAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIHNjcm9sbExlZnRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gSGFuZGxlIGNsaWNrL3RvdWNoIGV2ZW50cyBvbiBub2Rlcy9saW5rc1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIGlmICghc3RhdGUuaXNQb2ludGVyUHJlc3NlZCkge1xuICAgICAgICByZXR1cm47IC8vIGRvbid0IHRyaWdnZXIgY2xpY2sgZXZlbnRzIGlmIHBvaW50ZXIgaXMgbm90IHByZXNzZWQgb24gdGhlIGNhbnZhc1xuICAgICAgfVxuICAgICAgc3RhdGUuaXNQb2ludGVyUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgaWYgKHN0YXRlLmlzUG9pbnRlckRyYWdnaW5nKSB7XG4gICAgICAgIHN0YXRlLmlzUG9pbnRlckRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybjsgLy8gZG9uJ3QgdHJpZ2dlciBjbGljayBldmVudHMgYWZ0ZXIgcG9pbnRlciBkcmFnIChwYW4gLyBub2RlIGRyYWcgZnVuY3Rpb25hbGl0eSlcbiAgICAgIH1cbiAgICAgIHZhciBjYkV2ZW50cyA9IFtldiwgc3RhdGUucG9pbnRlckRvd25FdmVudF07XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB0cmlnZ2VyIGNsaWNrIGV2ZW50cyBhc3luY2hyb25vdXNseSwgdG8gYWxsb3cgaG92ZXJPYmogdG8gYmUgc2V0IChvbiBmcmFtZSlcbiAgICAgICAgaWYgKGV2LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAgIC8vIG1vdXNlIGxlZnQtY2xpY2sgb3IgdG91Y2hcbiAgICAgICAgICBpZiAoc3RhdGUuaG92ZXJPYmopIHtcbiAgICAgICAgICAgIHZhciBmbiA9IHN0YXRlW1wib25cIi5jb25jYXQoc3RhdGUuaG92ZXJPYmoudHlwZSwgXCJDbGlja1wiKV07XG4gICAgICAgICAgICBmbiAmJiBmbi5hcHBseSh2b2lkIDAsIFtzdGF0ZS5ob3Zlck9iai5kXS5jb25jYXQoY2JFdmVudHMpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUub25CYWNrZ3JvdW5kQ2xpY2sgJiYgc3RhdGUub25CYWNrZ3JvdW5kQ2xpY2suYXBwbHkoc3RhdGUsIGNiRXZlbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2LmJ1dHRvbiA9PT0gMikge1xuICAgICAgICAgIC8vIG1vdXNlIHJpZ2h0LWNsaWNrXG4gICAgICAgICAgaWYgKHN0YXRlLmhvdmVyT2JqKSB7XG4gICAgICAgICAgICB2YXIgX2ZuID0gc3RhdGVbXCJvblwiLmNvbmNhdChzdGF0ZS5ob3Zlck9iai50eXBlLCBcIlJpZ2h0Q2xpY2tcIildO1xuICAgICAgICAgICAgX2ZuICYmIF9mbi5hcHBseSh2b2lkIDAsIFtzdGF0ZS5ob3Zlck9iai5kXS5jb25jYXQoY2JFdmVudHMpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUub25CYWNrZ3JvdW5kUmlnaHRDbGljayAmJiBzdGF0ZS5vbkJhY2tncm91bmRSaWdodENsaWNrLmFwcGx5KHN0YXRlLCBjYkV2ZW50cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICBpZiAoIXN0YXRlLm9uQmFja2dyb3VuZFJpZ2h0Q2xpY2sgJiYgIXN0YXRlLm9uTm9kZVJpZ2h0Q2xpY2sgJiYgIXN0YXRlLm9uTGlua1JpZ2h0Q2xpY2spIHJldHVybiB0cnVlOyAvLyBkZWZhdWx0IGNvbnRleHRtZW51IGJlaGF2aW9yXG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICAgIHN0YXRlLmZvcmNlR3JhcGgoY3R4KTtcbiAgICBzdGF0ZS5zaGFkb3dHcmFwaChzaGFkb3dDdHgpO1xuXG4gICAgLy9cblxuICAgIHZhciByZWZyZXNoU2hhZG93Q2FudmFzID0gdGhyb3R0bGUoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gd2lwZSBjYW52YXNcbiAgICAgIGNsZWFyQ2FudmFzKHNoYWRvd0N0eCwgc3RhdGUud2lkdGgsIHN0YXRlLmhlaWdodCk7XG5cbiAgICAgIC8vIEFkanVzdCBsaW5rIGhvdmVyIGFyZWFcbiAgICAgIHN0YXRlLnNoYWRvd0dyYXBoLmxpbmtXaWR0aChmdW5jdGlvbiAobCkge1xuICAgICAgICByZXR1cm4gYWNjZXNzb3JGbihzdGF0ZS5saW5rV2lkdGgpKGwpICsgc3RhdGUubGlua0hvdmVyUHJlY2lzaW9uO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHJlZHJhd1xuICAgICAgdmFyIHQgPSB6b29tVHJhbnNmb3JtKHN0YXRlLmNhbnZhcyk7XG4gICAgICBzdGF0ZS5zaGFkb3dHcmFwaC5nbG9iYWxTY2FsZSh0LmspLnRpY2tGcmFtZSgpO1xuICAgIH0sIEhPVkVSX0NBTlZBU19USFJPVFRMRV9ERUxBWSk7XG4gICAgc3RhdGUuZmx1c2hTaGFkb3dDYW52YXMgPSByZWZyZXNoU2hhZG93Q2FudmFzLmZsdXNoOyAvLyBob29rIHRvIGltbWVkaWF0ZWx5IGludm9rZSBzaGFkb3cgY2FudmFzIHBhaW50XG5cbiAgICAvLyBLaWNrLW9mZiByZW5kZXJlclxuICAgICh0aGlzLl9hbmltYXRpb25DeWNsZSA9IGZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gICAgICAvLyBJSUZFXG4gICAgICB2YXIgZG9SZWRyYXcgPSAhc3RhdGUuYXV0b1BhdXNlUmVkcmF3IHx8ICEhc3RhdGUubmVlZHNSZWRyYXcgfHwgc3RhdGUuZm9yY2VHcmFwaC5pc0VuZ2luZVJ1bm5pbmcoKSB8fCBzdGF0ZS5ncmFwaERhdGEubGlua3Muc29tZShmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5fX3Bob3RvbnMgJiYgZC5fX3Bob3RvbnMubGVuZ3RoO1xuICAgICAgfSk7XG4gICAgICBzdGF0ZS5uZWVkc1JlZHJhdyA9IGZhbHNlO1xuICAgICAgaWYgKHN0YXRlLmVuYWJsZVBvaW50ZXJJbnRlcmFjdGlvbikge1xuICAgICAgICAvLyBVcGRhdGUgdG9vbHRpcCBhbmQgdHJpZ2dlciBvbkhvdmVyIGV2ZW50c1xuICAgICAgICB2YXIgb2JqID0gIXN0YXRlLmlzUG9pbnRlckRyYWdnaW5nID8gZ2V0T2JqVW5kZXJQb2ludGVyKCkgOiBudWxsOyAvLyBkb24ndCBob3ZlciBkdXJpbmcgZHJhZ1xuICAgICAgICBpZiAob2JqICE9PSBzdGF0ZS5ob3Zlck9iaikge1xuICAgICAgICAgIHZhciBwcmV2T2JqID0gc3RhdGUuaG92ZXJPYmo7XG4gICAgICAgICAgdmFyIHByZXZPYmpUeXBlID0gcHJldk9iaiA/IHByZXZPYmoudHlwZSA6IG51bGw7XG4gICAgICAgICAgdmFyIG9ialR5cGUgPSBvYmogPyBvYmoudHlwZSA6IG51bGw7XG4gICAgICAgICAgaWYgKHByZXZPYmpUeXBlICYmIHByZXZPYmpUeXBlICE9PSBvYmpUeXBlKSB7XG4gICAgICAgICAgICAvLyBIb3ZlciBvdXRcbiAgICAgICAgICAgIHZhciBmbiA9IHN0YXRlW1wib25cIi5jb25jYXQocHJldk9ialR5cGUsIFwiSG92ZXJcIildO1xuICAgICAgICAgICAgZm4gJiYgZm4obnVsbCwgcHJldk9iai5kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9ialR5cGUpIHtcbiAgICAgICAgICAgIC8vIEhvdmVyIGluXG4gICAgICAgICAgICB2YXIgX2ZuMiA9IHN0YXRlW1wib25cIi5jb25jYXQob2JqVHlwZSwgXCJIb3ZlclwiKV07XG4gICAgICAgICAgICBfZm4yICYmIF9mbjIob2JqLmQsIHByZXZPYmpUeXBlID09PSBvYmpUeXBlID8gcHJldk9iai5kIDogbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlLnRvb2x0aXAuY29udGVudChvYmogPyBhY2Nlc3NvckZuKHN0YXRlW1wiXCIuY29uY2F0KG9iai50eXBlLnRvTG93ZXJDYXNlKCksIFwiTGFiZWxcIildKShvYmouZCkgfHwgbnVsbCA6IG51bGwpO1xuXG4gICAgICAgICAgLy8gc2V0IHBvaW50ZXIgaWYgaG92ZXJlZCBvYmplY3QgaXMgY2xpY2thYmxlXG4gICAgICAgICAgc3RhdGUuY2FudmFzLmNsYXNzTGlzdFsob2JqICYmIHN0YXRlW1wib25cIi5jb25jYXQob2JqVHlwZSwgXCJDbGlja1wiKV0gfHwgIW9iaiAmJiBzdGF0ZS5vbkJhY2tncm91bmRDbGljaykgJiYgYWNjZXNzb3JGbihzdGF0ZS5zaG93UG9pbnRlckN1cnNvcikob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqLmQpID8gJ2FkZCcgOiAncmVtb3ZlJ10oJ2NsaWNrYWJsZScpO1xuICAgICAgICAgIHN0YXRlLmhvdmVyT2JqID0gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGRvUmVkcmF3ICYmIHJlZnJlc2hTaGFkb3dDYW52YXMoKTtcbiAgICAgIH1cbiAgICAgIGlmIChkb1JlZHJhdykge1xuICAgICAgICAvLyBXaXBlIGNhbnZhc1xuICAgICAgICBjbGVhckNhbnZhcyhjdHgsIHN0YXRlLndpZHRoLCBzdGF0ZS5oZWlnaHQpO1xuXG4gICAgICAgIC8vIEZyYW1lIGN5Y2xlXG4gICAgICAgIHZhciBnbG9iYWxTY2FsZSA9IHpvb21UcmFuc2Zvcm0oc3RhdGUuY2FudmFzKS5rO1xuICAgICAgICBzdGF0ZS5vblJlbmRlckZyYW1lUHJlICYmIHN0YXRlLm9uUmVuZGVyRnJhbWVQcmUoY3R4LCBnbG9iYWxTY2FsZSk7XG4gICAgICAgIHN0YXRlLmZvcmNlR3JhcGguZ2xvYmFsU2NhbGUoZ2xvYmFsU2NhbGUpLnRpY2tGcmFtZSgpO1xuICAgICAgICBzdGF0ZS5vblJlbmRlckZyYW1lUG9zdCAmJiBzdGF0ZS5vblJlbmRlckZyYW1lUG9zdChjdHgsIGdsb2JhbFNjYWxlKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnR3ZWVuR3JvdXAudXBkYXRlKCk7IC8vIHVwZGF0ZSBjYW52YXMgYW5pbWF0aW9uIHR3ZWVuc1xuXG4gICAgICBzdGF0ZS5hbmltYXRpb25GcmFtZVJlcXVlc3RJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICB9KSgpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZUZuKHN0YXRlKSB7fVxufSk7XG5cbmV4cG9ydCB7IGZvcmNlR3JhcGggYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/force-graph/dist/force-graph.mjs\n");

/***/ })

};
;